{
    "docs": [
        {
            "location": "/",
            "text": "Edmunds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEdmunds is a Python framework for building web applications\nwith a firm base to start from. Edmunds takes away the pain of\nbootstrap code so you can kickoff with the things that really\nmatter.\n\n\nGetting Started\n\n\n\n\nDownload an Edmunds Instance to kick-start your project: \nhttps://github.com/LowieHuyghe/edmunds-instance/archive/master.zip\n\n\nUnzip it and rename it after your project.\n\n\nSetup you virtual environment for your project\n(see \nThe Hitchhiker's guide to Python\n).\n\n\nActivate your project's virtual environment\n\n\nInstall the required package setuptools_scm: \npip install setuptools_scm\n\n\nInstall all other dependencies: \npip install -r requirements.txt\n\n\nTry starting it up! \npython main.py\n\n\n\n\nFurther Documentation\n\n\nSee: \nhttps://lowiehuyghe.github.io/edmunds/",
            "title": "Introduction"
        },
        {
            "location": "/#edmunds",
            "text": "Edmunds is a Python framework for building web applications\nwith a firm base to start from. Edmunds takes away the pain of\nbootstrap code so you can kickoff with the things that really\nmatter.",
            "title": "Edmunds"
        },
        {
            "location": "/#getting-started",
            "text": "Download an Edmunds Instance to kick-start your project:  https://github.com/LowieHuyghe/edmunds-instance/archive/master.zip  Unzip it and rename it after your project.  Setup you virtual environment for your project\n(see  The Hitchhiker's guide to Python ).  Activate your project's virtual environment  Install the required package setuptools_scm:  pip install setuptools_scm  Install all other dependencies:  pip install -r requirements.txt  Try starting it up!  python main.py",
            "title": "Getting Started"
        },
        {
            "location": "/#further-documentation",
            "text": "See:  https://lowiehuyghe.github.io/edmunds/",
            "title": "Further Documentation"
        },
        {
            "location": "/coreconcepts/applicationmiddleware/",
            "text": "Application Middleware\n\n\nApplication Middleware is the proper way of layering your application. Middleware can be used to add functionality to your application when processing calls. The middleware gets called each time your application is called.\n\n\nApplication Middleware\n\n\nDefine\n\n\nDefine your Application Middleware like so:\n\n\nfrom Edmunds.Foundation.ApplicationMiddleware import ApplicationMiddleware\n\nclass MyApplicationMiddleware(ApplicationMiddleware):\n    \"\"\"\n    My Application Middleware\n    \"\"\"\n\n    def handle(self, environment, startResponse):\n        \"\"\"\n        Handle the middleware\n        :param environment:     The environment\n        :type  environment:     Environment\n        :param startResponse:   The response\n        :type  startResponse:   Response\n        \"\"\"\n\n        return super(MyApplicationMiddleware, self).handle(environment, startResponse)\n\n\n\n\n\n\nNote: Application Middleware is th equivalent of the Flask Middleware using wsgi_app-wrappers.\n\n\n\n\nRegister\n\n\nRegister the Application Middleware once it needs to be loaded:\n\n\nfrom app.Foundation.MyApplicationMiddleware import MyApplicationMiddleware\n\napp.middleware(MyApplicationMiddleware)\n\n\n\n\nThis way the handle-function of your Application Middleware is called.\n\n\n\n\nNote: Application Middleware can only be registered once.",
            "title": "Application Middleware"
        },
        {
            "location": "/coreconcepts/applicationmiddleware/#application-middleware",
            "text": "Application Middleware is the proper way of layering your application. Middleware can be used to add functionality to your application when processing calls. The middleware gets called each time your application is called.",
            "title": "Application Middleware"
        },
        {
            "location": "/coreconcepts/applicationmiddleware/#application-middleware_1",
            "text": "",
            "title": "Application Middleware"
        },
        {
            "location": "/coreconcepts/applicationmiddleware/#define",
            "text": "Define your Application Middleware like so:  from Edmunds.Foundation.ApplicationMiddleware import ApplicationMiddleware\n\nclass MyApplicationMiddleware(ApplicationMiddleware):\n    \"\"\"\n    My Application Middleware\n    \"\"\"\n\n    def handle(self, environment, startResponse):\n        \"\"\"\n        Handle the middleware\n        :param environment:     The environment\n        :type  environment:     Environment\n        :param startResponse:   The response\n        :type  startResponse:   Response\n        \"\"\"\n\n        return super(MyApplicationMiddleware, self).handle(environment, startResponse)   Note: Application Middleware is th equivalent of the Flask Middleware using wsgi_app-wrappers.",
            "title": "Define"
        },
        {
            "location": "/coreconcepts/applicationmiddleware/#register",
            "text": "Register the Application Middleware once it needs to be loaded:  from app.Foundation.MyApplicationMiddleware import MyApplicationMiddleware\n\napp.middleware(MyApplicationMiddleware)  This way the handle-function of your Application Middleware is called.   Note: Application Middleware can only be registered once.",
            "title": "Register"
        },
        {
            "location": "/coreconcepts/serviceproviders/",
            "text": "Service Providers\n\n\nService Providers are a way of keeping the application as light as possible.\nThis is done by separating your application in modules and only loading the modules you need.\n\n\nDefine\n\n\nDefine your Service Provider like so:\n\n\nfrom Edmunds.Support.ServiceProvider import ServiceProvider\n\nclass MyServiceProvider(ServiceProvider):\n    \"\"\"\n    My Service Provider\n    \"\"\"\n\n    def register(self):\n        \"\"\"\n        Register the service provider\n        \"\"\"\n        # Load in your module\n        pass\n\n\n\n\nRegister\n\n\nRegister the Service Provider once it needs to be loaded:\n\n\nfrom app.Providers.MyServiceProvider import MyServiceProvider\n\napp.register(MyServiceProvider)\n\n\n\n\nThis way the register-function of your Service Provider provider is called.\n\n\n\n\nNote: A Service Provider can only be registered once.",
            "title": "Service Providers"
        },
        {
            "location": "/coreconcepts/serviceproviders/#service-providers",
            "text": "Service Providers are a way of keeping the application as light as possible.\nThis is done by separating your application in modules and only loading the modules you need.",
            "title": "Service Providers"
        },
        {
            "location": "/coreconcepts/serviceproviders/#define",
            "text": "Define your Service Provider like so:  from Edmunds.Support.ServiceProvider import ServiceProvider\n\nclass MyServiceProvider(ServiceProvider):\n    \"\"\"\n    My Service Provider\n    \"\"\"\n\n    def register(self):\n        \"\"\"\n        Register the service provider\n        \"\"\"\n        # Load in your module\n        pass",
            "title": "Define"
        },
        {
            "location": "/coreconcepts/serviceproviders/#register",
            "text": "Register the Service Provider once it needs to be loaded:  from app.Providers.MyServiceProvider import MyServiceProvider\n\napp.register(MyServiceProvider)  This way the register-function of your Service Provider provider is called.   Note: A Service Provider can only be registered once.",
            "title": "Register"
        },
        {
            "location": "/gettingstarted/installation/",
            "text": "Installation (WIP)\n\n\nBefore everything we need to set up an environment to run the application in.\n\n\nBootstrap\n\n\n\n\nSetup virtual environment\n\n\nInstall requirements\n\n\nIf you want to support Google App Engine:\n\n\nInstall Google Cloud SDK\n\n\nInstall Google App Engine component\n\n\nAdd libs to \nPYTHONPATH",
            "title": "Installation"
        },
        {
            "location": "/gettingstarted/installation/#installation-wip",
            "text": "Before everything we need to set up an environment to run the application in.",
            "title": "Installation (WIP)"
        },
        {
            "location": "/gettingstarted/installation/#bootstrap",
            "text": "Setup virtual environment  Install requirements  If you want to support Google App Engine:  Install Google Cloud SDK  Install Google App Engine component  Add libs to  PYTHONPATH",
            "title": "Bootstrap"
        },
        {
            "location": "/gettingstarted/configuration/",
            "text": "Configuration\n\n\nConfiguration is key to setting up an application.\n\n\nHandling configuration\n\n\nHandling configuration is based upon the config-handling of Laravel. Original Flask-configuration-handling also still works.\n\nThe keys used to fetch the values are mapped to the original keys specified in the files like so:\n\n\nAPP_ENV > app.env\nSECRET_KEY > secret.key\nDATABASE = {\n    'mysql': {\n        'user' > database.mysql.user\n    }\n}\n\n\n\n\nFetching a value:\n\n\nvalue = app.config('database.mysql.ip')\n\n\n\n\nUpdating values at runtime:\n\n\napp.config({\n    'database.mysql.ip': 'localhost',\n})\n\n\n\n\nConfiguration-files\n\n\nConfiguring the application can be done in several places. There is the main configuration for the generic configuration of the application. And there is the environment specific configuration.\n\n\nSyntax\n\n\nThe default syntax in Flask configuration-files states that only key-value pares can be assigned and fetched:\n\n\nAPP_AUTHOR_NAME = 'Edmunds'\nAPP_AUTHOR_AGE = 'Unknown'\n\n\n\n\nWith Edmunds it is possible to use the following syntax with the same result:\n\n\nAPP = {\n    'author': {\n        'name': 'Edmunds',\n        'age': 'Unknown',\n    },\n}\n\n\n\n\nThis allows for cleaner configuration-files. The Edmunds-syntax will be processed and converted to the Flask-syntax, which results in the same input as the Flask-example.\n\n\nMain configuration\n\n\nThe main configuration is located in the \nconfig\n-directory. There it is separated by namespace. Example structure:\n\n\nconfig\n  > app.py\n  > database.py\n  > session.py\n\n\n\n\nThe configuration-key starts with an ALL-CAPS key that defines the namespace. Further division is done with dictionaries. Example of a possible \nsession.py\n:\n\n\nSESSION = {\n    'ttl': 3600,\n    'driver': 'memcache',\n    'memcache': {\n        'ip': '178.234.87.34'\n    },\n}\n\n\n\n\nEnvironment configuration\n\n\nSome configuration is specific to the runtime environment. It depends on the machine it is running on, or on the current environment (local, production or testing). This configuration is not included in the git-repository, which makes it ideal for security sensitive configuration (like the app-secret).\n\n\nThe environment configuration is specified in the \n.env.py\n-files in the root of the project. An example of an \n.env.py\n-file:\n\n\nAPP_ENV = 'local'\nSECRET_KEY = 'aFBHjD8SHhqj71LEEmoxc8bLH4lzUTr'\n\n\n\n\nThe current environment given in the above example (\nAPP_ENV\n) will try to load more specific configuration in \n.env.local.py\n. This allows you to use separate databases or caching (for example) depending on the current environment. Example of an \n.env.local.py\n-file:\n\n\nDATABASE = {\n    'mysql': {\n        'ip': '172.0.0.1',\n        'user': 'myuser',\n        'pass': 'mypass',\n    },\n}\n\n\n\n\nSpecifying the current environment\n\n\nThe current environment is set with the \nAPP_ENV\n-key. The first way to do this is in the \n.env.py\n-file as explained before. The second way is by settings an environment-variable \nAPP_ENV\n before creating the application. For example:\n\n\nexport APP_ENV=production\n\n\n\n\nThis will load \n.env.production.py\n when loading up the application.",
            "title": "Configuration"
        },
        {
            "location": "/gettingstarted/configuration/#configuration",
            "text": "Configuration is key to setting up an application.",
            "title": "Configuration"
        },
        {
            "location": "/gettingstarted/configuration/#handling-configuration",
            "text": "Handling configuration is based upon the config-handling of Laravel. Original Flask-configuration-handling also still works. \nThe keys used to fetch the values are mapped to the original keys specified in the files like so:  APP_ENV > app.env\nSECRET_KEY > secret.key\nDATABASE = {\n    'mysql': {\n        'user' > database.mysql.user\n    }\n}  Fetching a value:  value = app.config('database.mysql.ip')  Updating values at runtime:  app.config({\n    'database.mysql.ip': 'localhost',\n})",
            "title": "Handling configuration"
        },
        {
            "location": "/gettingstarted/configuration/#configuration-files",
            "text": "Configuring the application can be done in several places. There is the main configuration for the generic configuration of the application. And there is the environment specific configuration.",
            "title": "Configuration-files"
        },
        {
            "location": "/gettingstarted/configuration/#syntax",
            "text": "The default syntax in Flask configuration-files states that only key-value pares can be assigned and fetched:  APP_AUTHOR_NAME = 'Edmunds'\nAPP_AUTHOR_AGE = 'Unknown'  With Edmunds it is possible to use the following syntax with the same result:  APP = {\n    'author': {\n        'name': 'Edmunds',\n        'age': 'Unknown',\n    },\n}  This allows for cleaner configuration-files. The Edmunds-syntax will be processed and converted to the Flask-syntax, which results in the same input as the Flask-example.",
            "title": "Syntax"
        },
        {
            "location": "/gettingstarted/configuration/#main-configuration",
            "text": "The main configuration is located in the  config -directory. There it is separated by namespace. Example structure:  config\n  > app.py\n  > database.py\n  > session.py  The configuration-key starts with an ALL-CAPS key that defines the namespace. Further division is done with dictionaries. Example of a possible  session.py :  SESSION = {\n    'ttl': 3600,\n    'driver': 'memcache',\n    'memcache': {\n        'ip': '178.234.87.34'\n    },\n}",
            "title": "Main configuration"
        },
        {
            "location": "/gettingstarted/configuration/#environment-configuration",
            "text": "Some configuration is specific to the runtime environment. It depends on the machine it is running on, or on the current environment (local, production or testing). This configuration is not included in the git-repository, which makes it ideal for security sensitive configuration (like the app-secret).  The environment configuration is specified in the  .env.py -files in the root of the project. An example of an  .env.py -file:  APP_ENV = 'local'\nSECRET_KEY = 'aFBHjD8SHhqj71LEEmoxc8bLH4lzUTr'  The current environment given in the above example ( APP_ENV ) will try to load more specific configuration in  .env.local.py . This allows you to use separate databases or caching (for example) depending on the current environment. Example of an  .env.local.py -file:  DATABASE = {\n    'mysql': {\n        'ip': '172.0.0.1',\n        'user': 'myuser',\n        'pass': 'mypass',\n    },\n}",
            "title": "Environment configuration"
        },
        {
            "location": "/gettingstarted/configuration/#specifying-the-current-environment",
            "text": "The current environment is set with the  APP_ENV -key. The first way to do this is in the  .env.py -file as explained before. The second way is by settings an environment-variable  APP_ENV  before creating the application. For example:  export APP_ENV=production  This will load  .env.production.py  when loading up the application.",
            "title": "Specifying the current environment"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/",
            "text": "Debugging and Profiling\n\n\nWhen all hell breaks loose or your application is underperforming, debugging and profiling is the answer.\n\n\nDebugging\n\n\nDebugging your application can be done in several ways. Using your IDE, \npdb\n, \npudb\n,... There are many options, but here \npdb\n and \npudb\n will be explained.\n\n\nPdb\n\n\nPdb, the python debugger\n, is a minimal debugger that comes straight out of the box in python. It runs in the terminal and has a minimal interface.\n\n\nStart pdb\n\n\npython -m pdb main.py\n\n\n\n\nDebug with pdb\n\n\nAdd breakpoints like so:\n\n\nfrom pdb import set_trace\nset_trace()\n\n\n\n\nMore debug-options can be found in the \ndocumentation\n.\n\n\nPudb\n\n\nPudb\n is a more interactive debugger. It runs in the terminal and has a nice interface which displays the code, stack, variables,...\n\n\nInstall pudb\n\n\n\n\nDownload the \ntar.gz\n from \nPyPi\n\n\nRun \n./setup.py install\n\n\n\n\nStart pudb\n\n\npudb main.py\n\n\n\n\nDebug with pudb\n\n\nfrom pudb import set_trace\nset_trace()\n\n\n\n\nMore debug-options can be found in the \ndocumentation\n.\n\n\nProfiling\n\n\nEdmunds comes with profiling built in. You can activate it in your settings:\n\n\nfrom Edmunds.Profiler.Drivers.CallGraph import CallGraph\nfrom Edmunds.Profiler.Drivers.Stream import Stream\nfrom Edmunds.Profiler.Drivers.BlackfireIo import BlackfireIo\nimport sys\n\nAPP = {\n    'debug': True,\n    'profiler':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'stream',\n                'driver': Stream,\n                # 'stream': sys.stdout,     # Optional, default: sys.stdout\n                # 'sort_by': ('calls'),     # Optional, default: ('time', 'calls')\n                # 'restrictions': (),       # Optional, default: ()\n            },\n            {\n                'name': 'callgraph',\n                'driver': CallGraph,\n                # 'directory': 'profs',     # Optional, default: 'profs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n            {\n                'name': 'blackfireio',\n                'driver': BlackfireIo,\n                # 'directory': 'profs',     # Optional, default: 'profs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances will all be used for profiling, so you can have multiple at once.\n\n\nThe available drivers are:\n- \nStream\n: Print output in the given stream.\n- \nCallGraph\n: Outputs in CallGraph-format to open in a viewer.\n- \nBlackfireIo\n: Output in BlackfireIo-format to upload to \nBlackfire.io\n.",
            "title": "Debugging and Profiling"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#debugging-and-profiling",
            "text": "When all hell breaks loose or your application is underperforming, debugging and profiling is the answer.",
            "title": "Debugging and Profiling"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#debugging",
            "text": "Debugging your application can be done in several ways. Using your IDE,  pdb ,  pudb ,... There are many options, but here  pdb  and  pudb  will be explained.",
            "title": "Debugging"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#pdb",
            "text": "Pdb, the python debugger , is a minimal debugger that comes straight out of the box in python. It runs in the terminal and has a minimal interface.",
            "title": "Pdb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#start-pdb",
            "text": "python -m pdb main.py",
            "title": "Start pdb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#debug-with-pdb",
            "text": "Add breakpoints like so:  from pdb import set_trace\nset_trace()  More debug-options can be found in the  documentation .",
            "title": "Debug with pdb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#pudb",
            "text": "Pudb  is a more interactive debugger. It runs in the terminal and has a nice interface which displays the code, stack, variables,...",
            "title": "Pudb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#install-pudb",
            "text": "Download the  tar.gz  from  PyPi  Run  ./setup.py install",
            "title": "Install pudb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#start-pudb",
            "text": "pudb main.py",
            "title": "Start pudb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#debug-with-pudb",
            "text": "from pudb import set_trace\nset_trace()  More debug-options can be found in the  documentation .",
            "title": "Debug with pudb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#profiling",
            "text": "Edmunds comes with profiling built in. You can activate it in your settings:  from Edmunds.Profiler.Drivers.CallGraph import CallGraph\nfrom Edmunds.Profiler.Drivers.Stream import Stream\nfrom Edmunds.Profiler.Drivers.BlackfireIo import BlackfireIo\nimport sys\n\nAPP = {\n    'debug': True,\n    'profiler':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'stream',\n                'driver': Stream,\n                # 'stream': sys.stdout,     # Optional, default: sys.stdout\n                # 'sort_by': ('calls'),     # Optional, default: ('time', 'calls')\n                # 'restrictions': (),       # Optional, default: ()\n            },\n            {\n                'name': 'callgraph',\n                'driver': CallGraph,\n                # 'directory': 'profs',     # Optional, default: 'profs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n            {\n                'name': 'blackfireio',\n                'driver': BlackfireIo,\n                # 'directory': 'profs',     # Optional, default: 'profs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n        ],\n    },\n}  The instances will all be used for profiling, so you can have multiple at once.  The available drivers are:\n-  Stream : Print output in the given stream.\n-  CallGraph : Outputs in CallGraph-format to open in a viewer.\n-  BlackfireIo : Output in BlackfireIo-format to upload to  Blackfire.io .",
            "title": "Profiling"
        },
        {
            "location": "/gettingstarted/errorsandlogging/",
            "text": "Errors and Logging\n\n\nError-handling and logging are built in and ready when you are.\n\n\nErrors\n\n\nEven the best programming logic and tests can't always foresee every possible scenario where errors can occure. You can report and render these exceptions by registering your own exception-handler.\n\n\nDefine\n\n\nDefine your Handler like so:\n\n\nfrom Edmunds.Exceptions.Handler import Handler as EdmundsHandler\n\nclass Handler(EdmundsHandler):\n    \"\"\"\n    Exception handler\n    \"\"\"\n\n    def report(self, exception):\n        \"\"\"\n        Report the exception\n        :param exception:   The exception\n        :type  exception:   Exception\n        \"\"\"\n        if super(Handler, self).report(exception):\n            pass  # Report\n\n    def render(self, exception):\n        \"\"\"\n        Render the exception\n        :param exception:   The exception\n        :type  exception:   Exception\n        :return:            The response\n        \"\"\"\n        return super(Handler, self).render(exception)\n\n\n\n\nRegister\n\n\nRegister the Handler for usage in \nconfig/app.py\n:\n\n\n'exceptions':\n{\n    'handler': Handler,\n},\n\n\n\n\nThis way the application knows to use your handler in case of an exception.\n\n\nLogging\n\n\nEdmunds comes with logging built in. You can activate it in your settings:\n\n\nfrom Edmunds.Log.Drivers.File import File\nfrom Edmunds.Log.Drivers.Stream import Stream\nfrom Edmunds.Log.Drivers.SysLog import SysLog\nfrom Edmunds.Log.Drivers.TimedFile import TimedFile\nfrom Edmunds.Log.Drivers.GoogleAppEngine import GoogleAppEngine\nfrom logging.handlers import SysLogHandler, SYSLOG_UDP_PORT\nfrom logging import WARNING\nfrom socket import SOCK_DGRAM\nimport sys\n\nAPP = {\n    'logging':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': 'logs',      # Optional, default: 'logs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n                # 'max_bytes': 0,           # Optional, default: 0\n                # 'backup_count': 0,        # Optional, default: 0\n                # 'level': WARNING,         # Optional, default: WARNING\n                # 'format': '%(message)s',  # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'timedfile',\n                'driver': TimedFile,\n                # 'directory': 'logs',                  # Optional, default: 'logs'\n                # 'prefix': 'Myapp.',                   # Optional, default: ''\n                # 'when': 'H',                          # Optional, default: 'D'\n                # 'interval': 12,                       # Optional, default: 1\n                # 'backup_count': 0,                    # Optional, default: 0\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'syslog',\n                'driver': SysLog,\n                # 'address': '/dev/log',                # Optional, default: ('localhost', SYSLOG_UDP_PORT)\n                # 'facility': SysLogHandler.LOG_USER,   # Optional, default: SysLogHandler.LOG_USER\n                # 'socktype': SOCK_DGRAM,               # Optional, default: SOCK_DGRAM\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'stream',\n                'driver': Stream,\n                # 'stream': sys.stderr,                 # Optional, default: sys.stderr\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'googleappengine',\n                'driver': GoogleAppEngine,\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '%(levelname)-8s %(asctime)s %(filename)s:%(lineno)s] %(message)s'\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances will all be used for logging, so you can have multiple at once.\n\n\nThe available drivers are:\n- \nFile\n: Print logs to file which can be separated by size.\n- \nTimedFile\n: Print logs to file which can be separated by time-interval.\n- \nSysLog\n: Print logs to syslog.\n- \nStream\n: Pring logs to given stream.\n- \nGoogleAppEngine\n: Pring logs to the Google App Engine stream when running in Google App Engine runtime.",
            "title": "Errors and Logging"
        },
        {
            "location": "/gettingstarted/errorsandlogging/#errors-and-logging",
            "text": "Error-handling and logging are built in and ready when you are.",
            "title": "Errors and Logging"
        },
        {
            "location": "/gettingstarted/errorsandlogging/#errors",
            "text": "Even the best programming logic and tests can't always foresee every possible scenario where errors can occure. You can report and render these exceptions by registering your own exception-handler.",
            "title": "Errors"
        },
        {
            "location": "/gettingstarted/errorsandlogging/#define",
            "text": "Define your Handler like so:  from Edmunds.Exceptions.Handler import Handler as EdmundsHandler\n\nclass Handler(EdmundsHandler):\n    \"\"\"\n    Exception handler\n    \"\"\"\n\n    def report(self, exception):\n        \"\"\"\n        Report the exception\n        :param exception:   The exception\n        :type  exception:   Exception\n        \"\"\"\n        if super(Handler, self).report(exception):\n            pass  # Report\n\n    def render(self, exception):\n        \"\"\"\n        Render the exception\n        :param exception:   The exception\n        :type  exception:   Exception\n        :return:            The response\n        \"\"\"\n        return super(Handler, self).render(exception)",
            "title": "Define"
        },
        {
            "location": "/gettingstarted/errorsandlogging/#register",
            "text": "Register the Handler for usage in  config/app.py :  'exceptions':\n{\n    'handler': Handler,\n},  This way the application knows to use your handler in case of an exception.",
            "title": "Register"
        },
        {
            "location": "/gettingstarted/errorsandlogging/#logging",
            "text": "Edmunds comes with logging built in. You can activate it in your settings:  from Edmunds.Log.Drivers.File import File\nfrom Edmunds.Log.Drivers.Stream import Stream\nfrom Edmunds.Log.Drivers.SysLog import SysLog\nfrom Edmunds.Log.Drivers.TimedFile import TimedFile\nfrom Edmunds.Log.Drivers.GoogleAppEngine import GoogleAppEngine\nfrom logging.handlers import SysLogHandler, SYSLOG_UDP_PORT\nfrom logging import WARNING\nfrom socket import SOCK_DGRAM\nimport sys\n\nAPP = {\n    'logging':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': 'logs',      # Optional, default: 'logs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n                # 'max_bytes': 0,           # Optional, default: 0\n                # 'backup_count': 0,        # Optional, default: 0\n                # 'level': WARNING,         # Optional, default: WARNING\n                # 'format': '%(message)s',  # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'timedfile',\n                'driver': TimedFile,\n                # 'directory': 'logs',                  # Optional, default: 'logs'\n                # 'prefix': 'Myapp.',                   # Optional, default: ''\n                # 'when': 'H',                          # Optional, default: 'D'\n                # 'interval': 12,                       # Optional, default: 1\n                # 'backup_count': 0,                    # Optional, default: 0\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'syslog',\n                'driver': SysLog,\n                # 'address': '/dev/log',                # Optional, default: ('localhost', SYSLOG_UDP_PORT)\n                # 'facility': SysLogHandler.LOG_USER,   # Optional, default: SysLogHandler.LOG_USER\n                # 'socktype': SOCK_DGRAM,               # Optional, default: SOCK_DGRAM\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'stream',\n                'driver': Stream,\n                # 'stream': sys.stderr,                 # Optional, default: sys.stderr\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'googleappengine',\n                'driver': GoogleAppEngine,\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '%(levelname)-8s %(asctime)s %(filename)s:%(lineno)s] %(message)s'\n            },\n        ],\n    },\n}  The instances will all be used for logging, so you can have multiple at once.  The available drivers are:\n-  File : Print logs to file which can be separated by size.\n-  TimedFile : Print logs to file which can be separated by time-interval.\n-  SysLog : Print logs to syslog.\n-  Stream : Pring logs to given stream.\n-  GoogleAppEngine : Pring logs to the Google App Engine stream when running in Google App Engine runtime.",
            "title": "Logging"
        },
        {
            "location": "/gettingstarted/console/",
            "text": "Console\n\n\nConsole usage is built in in Edmunds and uses default Flask CLI.\nEdmunds has wrappers to make usage easier and more organized.\n\n\nFlask CLI uses click to register and use commands. More on this in the\n\nFlask CLI documentation\n.\n\n\n\n\nThe Manager (base: \nedmunds.console.manager\n) is responsible for\nregistering the commands.\n\n\nThe Command (base: \nedmunds.console.command\n) is a wrapper that uses its\n\nrun\n-function as an entry-point for click. Option-decorators can be\ndefined there.\n\n\n\n\nUsage\n\n\nConstruct command\n\n\nCommands are by default located in the \napp.console.commands\n-module.\nAdd command decorators to the \nrun\n-function like you normally would\nwih click.\n\n\nfrom edmunds.console.command import Command\nimport click\n\nclass HelloWorldCommand(Command):\n    \"\"\"\n    Prints Hello World!\n    \"\"\"\n    @click.option('--what', default='World', help='Hello what?')\n    def run(self, what):\n        \"\"\"\n        Run the command\n        :param what:    Hello what?\n        \"\"\"\n        print('Hello %s!' % what)\n\n\n\n\nRegister commands\n\n\nThe manager is by default located in the \napp.console.manager\n-module. \nYou can register your custom commands (located in \napp.console.commands\n)\nin the manager. This will wrap the \nrun\n-function of the command in a\n\nclick.command\n-decorator so its available for console-usage.\n\n\n# ...\nfrom edmunds.console.manager import Manager as EdmundsManager\nfrom app.console.commands.helloworldcommand import HelloWorldCommand\n\nclass Manager(EdmundsManager):\n    # ...\n    def add_commands(self):\n        # ...\n        self.add_command('helloworld', HelloWorldCommand)\n\n\n\n\nConsole usage\n\n\nConsole-usage of your application has been integrated in \nmanage.py\n.\nIt's a wrapper for the \nflask\n-command which requires extra\nenvironment-variables. By default the manager in \napp.console.manager\n\nwill be loaded. You can use \nmanage.py\n by calling it in your\nruntime-environment:\n\n\npython manage.py --help\npython manage.py helloworld",
            "title": "Console"
        },
        {
            "location": "/gettingstarted/console/#console",
            "text": "Console usage is built in in Edmunds and uses default Flask CLI.\nEdmunds has wrappers to make usage easier and more organized.  Flask CLI uses click to register and use commands. More on this in the Flask CLI documentation .   The Manager (base:  edmunds.console.manager ) is responsible for\nregistering the commands.  The Command (base:  edmunds.console.command ) is a wrapper that uses its run -function as an entry-point for click. Option-decorators can be\ndefined there.",
            "title": "Console"
        },
        {
            "location": "/gettingstarted/console/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/gettingstarted/console/#construct-command",
            "text": "Commands are by default located in the  app.console.commands -module.\nAdd command decorators to the  run -function like you normally would\nwih click.  from edmunds.console.command import Command\nimport click\n\nclass HelloWorldCommand(Command):\n    \"\"\"\n    Prints Hello World!\n    \"\"\"\n    @click.option('--what', default='World', help='Hello what?')\n    def run(self, what):\n        \"\"\"\n        Run the command\n        :param what:    Hello what?\n        \"\"\"\n        print('Hello %s!' % what)",
            "title": "Construct command"
        },
        {
            "location": "/gettingstarted/console/#register-commands",
            "text": "The manager is by default located in the  app.console.manager -module. \nYou can register your custom commands (located in  app.console.commands )\nin the manager. This will wrap the  run -function of the command in a click.command -decorator so its available for console-usage.  # ...\nfrom edmunds.console.manager import Manager as EdmundsManager\nfrom app.console.commands.helloworldcommand import HelloWorldCommand\n\nclass Manager(EdmundsManager):\n    # ...\n    def add_commands(self):\n        # ...\n        self.add_command('helloworld', HelloWorldCommand)",
            "title": "Register commands"
        },
        {
            "location": "/gettingstarted/console/#console-usage",
            "text": "Console-usage of your application has been integrated in  manage.py .\nIt's a wrapper for the  flask -command which requires extra\nenvironment-variables. By default the manager in  app.console.manager \nwill be loaded. You can use  manage.py  by calling it in your\nruntime-environment:  python manage.py --help\npython manage.py helloworld",
            "title": "Console usage"
        },
        {
            "location": "/http/requestmiddleware/",
            "text": "Request Middleware\n\n\nRequest Middleware is the proper way of layering your request-handling. It lets you add functionality before and after processing the request.\n\n\nRequest Middleware\n\n\nDefine\n\n\nDefine your Request Middleware like so:\n\n\nfrom Edmunds.Http.RequestMiddleware import RequestMiddleware\n\nclass MyRequestMiddleware(RequestMiddleware):\n    \"\"\"\n    My Request Middleware\n    \"\"\"\n\n    def before(self):\n        \"\"\"\n        Handle before the request\n        \"\"\"\n\n        return super(MyRequestMiddleware, self).before()\n\n    def after(self, response):\n        \"\"\"\n        Handle after the request\n        :param response:    The request response\n        :type  response:    flask.Response\n        :return:            The request response\n        :rtype:             flask.Response\n        \"\"\"\n\n        return super(MyRequestMiddleware, self).after(response)\n\n\n\n\n\n\nNote: The before- and after-function work respectively like the @app.before_request and @app.after_request of Flask.\n\n\n\n\nRegister\n\n\nRegister the Request Middleware in \nroutes.py\n as an option of the routes:\n\n\nfrom app.Http.MyRequestMiddleware import MyRequestMiddleware\nfrom app.Http.MyController import MyController\n\napp.route('/', middleware = [ MyRequestMiddleware ], uses = (MyController, 'get_index'))\n\n\n\n\nThis way the before- and after-function of your Request Middleware is called.\n\n\n\n\nNote: The order in which the middleware is given, will also be the order in which they are called.",
            "title": "Request Middleware"
        },
        {
            "location": "/http/requestmiddleware/#request-middleware",
            "text": "Request Middleware is the proper way of layering your request-handling. It lets you add functionality before and after processing the request.",
            "title": "Request Middleware"
        },
        {
            "location": "/http/requestmiddleware/#request-middleware_1",
            "text": "",
            "title": "Request Middleware"
        },
        {
            "location": "/http/requestmiddleware/#define",
            "text": "Define your Request Middleware like so:  from Edmunds.Http.RequestMiddleware import RequestMiddleware\n\nclass MyRequestMiddleware(RequestMiddleware):\n    \"\"\"\n    My Request Middleware\n    \"\"\"\n\n    def before(self):\n        \"\"\"\n        Handle before the request\n        \"\"\"\n\n        return super(MyRequestMiddleware, self).before()\n\n    def after(self, response):\n        \"\"\"\n        Handle after the request\n        :param response:    The request response\n        :type  response:    flask.Response\n        :return:            The request response\n        :rtype:             flask.Response\n        \"\"\"\n\n        return super(MyRequestMiddleware, self).after(response)   Note: The before- and after-function work respectively like the @app.before_request and @app.after_request of Flask.",
            "title": "Define"
        },
        {
            "location": "/http/requestmiddleware/#register",
            "text": "Register the Request Middleware in  routes.py  as an option of the routes:  from app.Http.MyRequestMiddleware import MyRequestMiddleware\nfrom app.Http.MyController import MyController\n\napp.route('/', middleware = [ MyRequestMiddleware ], uses = (MyController, 'get_index'))  This way the before- and after-function of your Request Middleware is called.   Note: The order in which the middleware is given, will also be the order in which they are called.",
            "title": "Register"
        },
        {
            "location": "/http/routing/",
            "text": "Routing\n\n\nRouting the request has slightly been modified with some inspiration from Laravel. The routing of Flask applies, but a minor change has been made so controllers can be used.\n\n\nBasic routing\n\n\napp.route('/', uses = (MyController, 'get_index'))\n\n\n\n\nThis will route the request to \nget_index\n in \nMyController\n:\n\n\nfrom Edmunds.Http.Controller import Controller\n\nclass MyController(Controller):\n    \"\"\"\n    My Controller\n    \"\"\"\n\n    def initialize(self, **params):\n        \"\"\"\n        Initialize the controller\n        :param params:      The parameters in the url\n        :type  params:      dict\n        \"\"\"\n        super(MyController, self).initialize()\n\n    def get_index(self):\n        \"\"\"\n        Get the index-page\n        \"\"\"\n        return 'Hello World!'\n\n\n\n\n\nAs you can see there is a method called \ninitialize\n. This method is responsible for initializing the controller.\n\n\nConstructing and initializing the controller is done in this order:\n\n\n\n\nConstruct the controller \n(\n__init__\n)\n\n\nInitialize the controller \n(\ninitialize\n)\n\n\nCall the method and return the response \n(\nget_index\n)\n\n\n\n\nDynamic routing\n\n\nAdding variable parts to a url is done by marking them with special sections:\n\n\napp.route('/user/<username>', uses = (MyController, 'get_user'))\napp.route('/post/<int:post_id>', uses = (MyController, 'get_post')) # Using converters\n\n\n\n\nOther possible converters:\n- \nstring\n: accepts any text without a slash (the default)\n- \nint\n: accepts integers\n- \nfloat\n: like int but for floating point values\n- \npath\n: like the default but also accepts slashes\n- \nany\n: matches one of the items provided\n- \nuuid\n: accepts UUID strings\n\n\nThese parameters are catched in the controller as followed:\n\n\ndef get_user(self, username = None):\n        return 'User: %s' % username\n\ndef get_post(self, post_id = None):\n        return 'Post with id: %d' % post_id\n\n\n\n\nAs seen previously, the parameters are also passed to the \ninitialize\n-method.\n\n\nHTTP methods\n\n\nHTTP knows different methods which can be defined in the routes. By default the route will listen to \nGET\n-requests.\n\n\napp.route('/login', uses = (LoginController, 'get_login'), methods = ['GET'])\napp.route('/login', uses = (LoginController, 'post_login'), methods = ['POST'])\n\n\n\n\nAll supported methods:\n- \nGET\n\n- \nHEAD\n\n- \nPOST\n\n- \nPUT\n\n- \nDELETE\n\n- \nOPTIONS",
            "title": "Routing"
        },
        {
            "location": "/http/routing/#routing",
            "text": "Routing the request has slightly been modified with some inspiration from Laravel. The routing of Flask applies, but a minor change has been made so controllers can be used.",
            "title": "Routing"
        },
        {
            "location": "/http/routing/#basic-routing",
            "text": "app.route('/', uses = (MyController, 'get_index'))  This will route the request to  get_index  in  MyController :  from Edmunds.Http.Controller import Controller\n\nclass MyController(Controller):\n    \"\"\"\n    My Controller\n    \"\"\"\n\n    def initialize(self, **params):\n        \"\"\"\n        Initialize the controller\n        :param params:      The parameters in the url\n        :type  params:      dict\n        \"\"\"\n        super(MyController, self).initialize()\n\n    def get_index(self):\n        \"\"\"\n        Get the index-page\n        \"\"\"\n        return 'Hello World!'  As you can see there is a method called  initialize . This method is responsible for initializing the controller.  Constructing and initializing the controller is done in this order:   Construct the controller  ( __init__ )  Initialize the controller  ( initialize )  Call the method and return the response  ( get_index )",
            "title": "Basic routing"
        },
        {
            "location": "/http/routing/#dynamic-routing",
            "text": "Adding variable parts to a url is done by marking them with special sections:  app.route('/user/<username>', uses = (MyController, 'get_user'))\napp.route('/post/<int:post_id>', uses = (MyController, 'get_post')) # Using converters  Other possible converters:\n-  string : accepts any text without a slash (the default)\n-  int : accepts integers\n-  float : like int but for floating point values\n-  path : like the default but also accepts slashes\n-  any : matches one of the items provided\n-  uuid : accepts UUID strings  These parameters are catched in the controller as followed:  def get_user(self, username = None):\n        return 'User: %s' % username\n\ndef get_post(self, post_id = None):\n        return 'Post with id: %d' % post_id  As seen previously, the parameters are also passed to the  initialize -method.",
            "title": "Dynamic routing"
        },
        {
            "location": "/http/routing/#http-methods",
            "text": "HTTP knows different methods which can be defined in the routes. By default the route will listen to  GET -requests.  app.route('/login', uses = (LoginController, 'get_login'), methods = ['GET'])\napp.route('/login', uses = (LoginController, 'post_login'), methods = ['POST'])  All supported methods:\n-  GET \n-  HEAD \n-  POST \n-  PUT \n-  DELETE \n-  OPTIONS",
            "title": "HTTP methods"
        },
        {
            "location": "/http/request/",
            "text": "Request\n\n\nRequest is available for usage when in request context.\n\n\nUsage\n\n\nThe current request can be accessed inside the controller and get used\nlike the flask request.\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        user_ip = self._request.remote_addr\n\n\n\n\n\n\nNote: for more on the request see the \nFlask documentation",
            "title": "Request"
        },
        {
            "location": "/http/request/#request",
            "text": "Request is available for usage when in request context.",
            "title": "Request"
        },
        {
            "location": "/http/request/#usage",
            "text": "The current request can be accessed inside the controller and get used\nlike the flask request.  from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        user_ip = self._request.remote_addr   Note: for more on the request see the  Flask documentation",
            "title": "Usage"
        },
        {
            "location": "/http/inputandvalidation/",
            "text": "Input and Validation\n\n\nFor an explanation on input and validation, you are on the right address.\n\n\nInput\n\n\nQuerystring-data, form-data and file-data are all combined in the Input-class.\nThe class takes the current request in its constructor and processed\nrequest.args, request.form and request.files. All data can be accessed like\nyou would access them separately.\n\n\nfrom edmunds.http.input import Input\nfrom edmunds.globals import request\n\ninput = Input(request)\nusername = input['username']\npassword = input['password']\ncity = input.get('city', 'unknown')\n\n\n\n\n\n\nNote: for more on the request-data see the \ndocs\n\n\n\n\nUsage in Controllers\n\n\nControllers are by default equipped with an instance of the input object.\nYou can use it to access the submitted data.\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        username = self._input['username']\n        password = self._input['password']\n        city = self._input.get('city', 'unknown')\n\n\n\n\nValidation\n\n\nEdmunds has a validator which extends from \nwtforms.Form\n. You can use it\nlike you would use WTForms. Validator has one extra attribute: \nvalidates\n\nwhich keeps the state of the last call to \nvalidates()\n.\n\n\n\n\nNote: for more on WTForms see the \ndocs\n\n\n\n\nUsage with Input\n\n\nInput has the Validator builtin. You can use it by passing your Validator-class\nto the \nvalidate\n-function.\n\n\nfrom edmunds.validation.validator import Validator\nfrom wtforms import StringField, PasswordField, validators\nfrom edmunds.http.controller import Controller\n\nclass LoginValidator(Validator):\n    email = StringField('Email Address', [validators.Length(min=6, max=35)])\n    password = PasswordField('Password', [validators.DataRequired()])\n\nclass MyController(Controller):\n    def login(self):\n        validator = self._input.validate(LoginValidator)\n        if validator.validates:\n            pass",
            "title": "Input and Validation"
        },
        {
            "location": "/http/inputandvalidation/#input-and-validation",
            "text": "For an explanation on input and validation, you are on the right address.",
            "title": "Input and Validation"
        },
        {
            "location": "/http/inputandvalidation/#input",
            "text": "Querystring-data, form-data and file-data are all combined in the Input-class.\nThe class takes the current request in its constructor and processed\nrequest.args, request.form and request.files. All data can be accessed like\nyou would access them separately.  from edmunds.http.input import Input\nfrom edmunds.globals import request\n\ninput = Input(request)\nusername = input['username']\npassword = input['password']\ncity = input.get('city', 'unknown')   Note: for more on the request-data see the  docs",
            "title": "Input"
        },
        {
            "location": "/http/inputandvalidation/#usage-in-controllers",
            "text": "Controllers are by default equipped with an instance of the input object.\nYou can use it to access the submitted data.  from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        username = self._input['username']\n        password = self._input['password']\n        city = self._input.get('city', 'unknown')",
            "title": "Usage in Controllers"
        },
        {
            "location": "/http/inputandvalidation/#validation",
            "text": "Edmunds has a validator which extends from  wtforms.Form . You can use it\nlike you would use WTForms. Validator has one extra attribute:  validates \nwhich keeps the state of the last call to  validates() .   Note: for more on WTForms see the  docs",
            "title": "Validation"
        },
        {
            "location": "/http/inputandvalidation/#usage-with-input",
            "text": "Input has the Validator builtin. You can use it by passing your Validator-class\nto the  validate -function.  from edmunds.validation.validator import Validator\nfrom wtforms import StringField, PasswordField, validators\nfrom edmunds.http.controller import Controller\n\nclass LoginValidator(Validator):\n    email = StringField('Email Address', [validators.Length(min=6, max=35)])\n    password = PasswordField('Password', [validators.DataRequired()])\n\nclass MyController(Controller):\n    def login(self):\n        validator = self._input.validate(LoginValidator)\n        if validator.validates:\n            pass",
            "title": "Usage with Input"
        },
        {
            "location": "/http/session/",
            "text": "Session\n\n\nTo activate session, enabled it by adding instances to your settings:\n\n\nfrom edmunds.session.drivers.sessioncookie import SessionCookie\n\nAPP = {\n    'session':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'sessioncookie',\n                'driver': SessionCookie\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances will all be used for session, so you can have multiple at once.\n\n\nThe available drivers are:\n- \nSessionCookie\n: Sessions using cookies (see \ndocs\n)\n\n\nUsage\n\n\nController will have the first driver loaded for usage:\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        prev_username = self._session['username']\n        prev_username = self._session.pop('username', None)\n        del self._session['username']\n        self._session['username'] = self._input['username']\n\n\n\n\nUsage outside controller\n\n\nWhen in request-context, but not inside a controller, you can use the\napplication to get the driver-instance:\n\n\nsession = app.session()\nsession = app.session('sessioncookie')\n\nsession['key'] = 'value'\nprint session['key']\ndel session['key']",
            "title": "Session"
        },
        {
            "location": "/http/session/#session",
            "text": "To activate session, enabled it by adding instances to your settings:  from edmunds.session.drivers.sessioncookie import SessionCookie\n\nAPP = {\n    'session':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'sessioncookie',\n                'driver': SessionCookie\n            },\n        ],\n    },\n}  The instances will all be used for session, so you can have multiple at once.  The available drivers are:\n-  SessionCookie : Sessions using cookies (see  docs )",
            "title": "Session"
        },
        {
            "location": "/http/session/#usage",
            "text": "Controller will have the first driver loaded for usage:  from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        prev_username = self._session['username']\n        prev_username = self._session.pop('username', None)\n        del self._session['username']\n        self._session['username'] = self._input['username']",
            "title": "Usage"
        },
        {
            "location": "/http/session/#usage-outside-controller",
            "text": "When in request-context, but not inside a controller, you can use the\napplication to get the driver-instance:  session = app.session()\nsession = app.session('sessioncookie')\n\nsession['key'] = 'value'\nprint session['key']\ndel session['key']",
            "title": "Usage outside controller"
        },
        {
            "location": "/http/response/",
            "text": "Response\n\n\nResponse is available for usage when in request context.\n\n\nThe class implemented extends the Response-wrapper from Flask. So no\nchanges there. But a ResponseHelper has been implemented for your comfort.\nThe helper makes it easier to construct your responses.\n\n\n\n\nNote: for more on the response (not the helper) see the\n\nFlask documentation\n\n\n\n\nUsage\n\n\nThe current request can be accessed inside the controller and get used\nlike the flask request.\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Fix status for constructed responses\n        self._response.status(404)\n\n        # Assigns a value to a key\n        # Will be used when constructing json-, or render-responses\n        self._response.assign('name', 'Jon Snow')\n\n        # Assigns headers to constructed responses\n        self._response.header('XToken', 'mytoken')\n\n        # Assigns cookie to constructed responses\n        self._response.cookie('XToken', 'mytoken')\n\n        # Returns a rendered template (using assigned values)\n        result = self._response.render_template('mytemplate.html')\n\n        # Returns raw response with given content\n        return self._response.raw('My content')\n        # Returns json response with assigned values\n        return self._response.json()\n        # Returns response with rendered template (using assigned values)\n        return self._response.render('mytemplate.html')\n        # Returns response to redirect browser\n        return self._response.redirect('/newlocation')\n        # Returns file response\n        return self._response.file('filetodownload.txt')",
            "title": "Response"
        },
        {
            "location": "/http/response/#response",
            "text": "Response is available for usage when in request context.  The class implemented extends the Response-wrapper from Flask. So no\nchanges there. But a ResponseHelper has been implemented for your comfort.\nThe helper makes it easier to construct your responses.   Note: for more on the response (not the helper) see the Flask documentation",
            "title": "Response"
        },
        {
            "location": "/http/response/#usage",
            "text": "The current request can be accessed inside the controller and get used\nlike the flask request.  from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Fix status for constructed responses\n        self._response.status(404)\n\n        # Assigns a value to a key\n        # Will be used when constructing json-, or render-responses\n        self._response.assign('name', 'Jon Snow')\n\n        # Assigns headers to constructed responses\n        self._response.header('XToken', 'mytoken')\n\n        # Assigns cookie to constructed responses\n        self._response.cookie('XToken', 'mytoken')\n\n        # Returns a rendered template (using assigned values)\n        result = self._response.render_template('mytemplate.html')\n\n        # Returns raw response with given content\n        return self._response.raw('My content')\n        # Returns json response with assigned values\n        return self._response.json()\n        # Returns response with rendered template (using assigned values)\n        return self._response.render('mytemplate.html')\n        # Returns response to redirect browser\n        return self._response.redirect('/newlocation')\n        # Returns file response\n        return self._response.file('filetodownload.txt')",
            "title": "Usage"
        },
        {
            "location": "/http/visitor/",
            "text": "Visitor\n\n\nThe visitor class is used to get information regarding the client.\nBrowser-related-info, ip-based-location, localization,...\n\n\nTo make location and localization work, you will need to setup some\nconfiguration. See \nlocalization\n.\n\n\nUsage\n\n\nThe visitor object will be available in controllers when handling requests.\n\n\nfrom edmunds.http.controller import Controller\nfrom datetime import time, date\n\nclass MyController(Controller):\n    def login(self):\n\n        # Client info\n        client_os = self._visitor.client.os\n        client_browser = self._visitor.client.browser\n        client_device = self._visitor.client.device\n        client_is_mobile = self._visitor.client.is_mobile\n        client_is_bot = self._visitor.client.is_bot\n        # ...\n\n        # Ip-based-location\n        country_iso = self._visitor.location.country.iso_code\n        city_name = self._visitor.location.city.name\n        # ...\n\n        # Localization\n        time_str = self._visitor.localization.time.time(time(14, 3, 2))\n        date_str = self._visitor.localization.time.date(date(1992, 6, 7))\n        # ...\n        cost = self._visitor.localization.number.currency(4.56, 'EUR')\n        number = self._visitor.localization.number.number(3456.64)\n        # ...\n        is_rtl = self._visitor.localization.rtl\n        locale = self._visitor.localization.locale\n        # ...",
            "title": "Visitor"
        },
        {
            "location": "/http/visitor/#visitor",
            "text": "The visitor class is used to get information regarding the client.\nBrowser-related-info, ip-based-location, localization,...  To make location and localization work, you will need to setup some\nconfiguration. See  localization .",
            "title": "Visitor"
        },
        {
            "location": "/http/visitor/#usage",
            "text": "The visitor object will be available in controllers when handling requests.  from edmunds.http.controller import Controller\nfrom datetime import time, date\n\nclass MyController(Controller):\n    def login(self):\n\n        # Client info\n        client_os = self._visitor.client.os\n        client_browser = self._visitor.client.browser\n        client_device = self._visitor.client.device\n        client_is_mobile = self._visitor.client.is_mobile\n        client_is_bot = self._visitor.client.is_bot\n        # ...\n\n        # Ip-based-location\n        country_iso = self._visitor.location.country.iso_code\n        city_name = self._visitor.location.city.name\n        # ...\n\n        # Localization\n        time_str = self._visitor.localization.time.time(time(14, 3, 2))\n        date_str = self._visitor.localization.time.date(date(1992, 6, 7))\n        # ...\n        cost = self._visitor.localization.number.currency(4.56, 'EUR')\n        number = self._visitor.localization.number.number(3456.64)\n        # ...\n        is_rtl = self._visitor.localization.rtl\n        locale = self._visitor.localization.locale\n        # ...",
            "title": "Usage"
        },
        {
            "location": "/data/storage/",
            "text": "Storage\n\n\nFile-storage is a basic, necessary thing for every application.\nAnd in Edmunds it's highly customizable!\n\n\nSettings\n\n\nYou can set your storage preferences in the settings:\n\n\nfrom Edmunds.Storage.Drivers.File import File\nfrom Edmunds.Storage.Drivers.GoogleCloudStorage import GoogleCloudStorage\n\nAPP = {\n    'storage':\n    {\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': '/storage',  # Optional, default: '/storage'\n                # 'files_path': 'files',    # Optional, default: 'files'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n            {\n                'name': 'googlecloudstorage',\n                'driver': GoogleCloudStorage,\n                # 'bucket': 'mybucket',     # Optional, default: default bucket\n                # 'directory': '/storage',  # Optional, default: '/storage'\n                # 'files_path': 'files',    # Optional, default: 'files'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances can be used for storage, so you can have multiple at once.\nThe first one will be used by default.\n\n\nThe available drivers are:\n- \nFile\n: Store files using the default file-system.\n- \nGoogleCloudStorage\n: Store files using Google Cloud Storage.\n\n\nUsage\n\n\nYou can use the handler like so:\n\n\n# Fetch the default driver, or by name\ndriver = app.fs()\ndriver = app.fs('googlecloudstorage')\n\n# Path\n# This function is used when processing the input of the other functions below\nabsolute_path = app.fs().path('file.txt')  # /abs_path_to_storage/files/{prefix}file.txt\nabsolute_path = app.fs().path('/file.txt')  # /abs_path_to_storage/{prefix}file.txt\nabsolute_path = app.fs().path('directory/')  # /abs_path_to_storage/files/directory/\nabsolute_path = app.fs().path('/directory/')  # /abs_path_to_storage/directory/\nabsolute_path = app.fs().path(None)  # /abs_path_to_storage/files/\nabsolute_path = app.fs().path('/')  # /abs_path_to_storage/\n# Each function can set the prefix for that call:\nabsolute_path = app.fs().path('file.txt', prefix='')  # /abs_path_to_storage/files/file.txt\n\n# Write stream\nwrite_stream = app.fs().write_stream('file.txt')\n\n# Read stream\nwrite_stream = app.fs().read_stream('file.txt', prefix='')\n\n# Copy file\nsuccess = app.fs().copy('file.txt', 'file.txt.bak')\n\n# Remove file\nsuccess = app.fs().delete('file.txt', prefix='')\n\n# Exists?\ndoes_not_exist = app.fs().exists('file.txt')",
            "title": "Storage"
        },
        {
            "location": "/data/storage/#storage",
            "text": "File-storage is a basic, necessary thing for every application.\nAnd in Edmunds it's highly customizable!",
            "title": "Storage"
        },
        {
            "location": "/data/storage/#settings",
            "text": "You can set your storage preferences in the settings:  from Edmunds.Storage.Drivers.File import File\nfrom Edmunds.Storage.Drivers.GoogleCloudStorage import GoogleCloudStorage\n\nAPP = {\n    'storage':\n    {\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': '/storage',  # Optional, default: '/storage'\n                # 'files_path': 'files',    # Optional, default: 'files'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n            {\n                'name': 'googlecloudstorage',\n                'driver': GoogleCloudStorage,\n                # 'bucket': 'mybucket',     # Optional, default: default bucket\n                # 'directory': '/storage',  # Optional, default: '/storage'\n                # 'files_path': 'files',    # Optional, default: 'files'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n        ],\n    },\n}  The instances can be used for storage, so you can have multiple at once.\nThe first one will be used by default.  The available drivers are:\n-  File : Store files using the default file-system.\n-  GoogleCloudStorage : Store files using Google Cloud Storage.",
            "title": "Settings"
        },
        {
            "location": "/data/storage/#usage",
            "text": "You can use the handler like so:  # Fetch the default driver, or by name\ndriver = app.fs()\ndriver = app.fs('googlecloudstorage')\n\n# Path\n# This function is used when processing the input of the other functions below\nabsolute_path = app.fs().path('file.txt')  # /abs_path_to_storage/files/{prefix}file.txt\nabsolute_path = app.fs().path('/file.txt')  # /abs_path_to_storage/{prefix}file.txt\nabsolute_path = app.fs().path('directory/')  # /abs_path_to_storage/files/directory/\nabsolute_path = app.fs().path('/directory/')  # /abs_path_to_storage/directory/\nabsolute_path = app.fs().path(None)  # /abs_path_to_storage/files/\nabsolute_path = app.fs().path('/')  # /abs_path_to_storage/\n# Each function can set the prefix for that call:\nabsolute_path = app.fs().path('file.txt', prefix='')  # /abs_path_to_storage/files/file.txt\n\n# Write stream\nwrite_stream = app.fs().write_stream('file.txt')\n\n# Read stream\nwrite_stream = app.fs().read_stream('file.txt', prefix='')\n\n# Copy file\nsuccess = app.fs().copy('file.txt', 'file.txt.bak')\n\n# Remove file\nsuccess = app.fs().delete('file.txt', prefix='')\n\n# Exists?\ndoes_not_exist = app.fs().exists('file.txt')",
            "title": "Usage"
        },
        {
            "location": "/data/database/",
            "text": "Database\n\n\nDatabase usage is built in in Edmunds and uses\n\nFlask-SQLAlchemy\n.\n\n\nSettings\n\n\nYou can set your database preferences in the settings:\n\n\nfrom edmunds.database.drivers.mysql import MySql\nfrom edmunds.database.drivers.postgresql import PostgreSql\nfrom edmunds.database.drivers.sqlite import Sqlite\n\nAPP = {\n    'database':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'mysql',\n                'driver': MySql,\n                'user': 'root',\n                'pass': 'root',\n                'host': 'localhost',\n                'database': 'edmunds',\n                # 'port': '3306',   # Optional, default: '3306'\n            },\n            {\n                'name': 'postgresql',\n                'driver': PostgreSql,\n                'user': 'root',\n                'pass': 'root',\n                'host': 'localhost',\n                'database': 'edmunds',\n                # 'port': '5432',   # Optional, default: '5432'\n            },\n            {\n                'name': 'sqlite',\n                'driver': Sqlite,\n                'file': 'sqlite.db',\n                # 'storage': 'storage_name',    # Optional, default storage used as default\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances can be used for database, so you can have multiple at once.\nThe first one will be used by default.\n\n\nThe available drivers are:\n- \nMySql\n: For MySQL databases.\n- \nPostgreSql\n: For PostgreSQL databases.\n- \nSQLite\n: For SQLite databases.\n\n\n\n\nMore in detail: the default instance will be used as \nSQLALCHEMY_DATABASE_URI\n\nin SQLAlchemy. Other instances (not including the default instance) will\nbe added to \nSQLALCHEMY_BINDS\n.\n\n\n\n\nUsage\n\n\nWhen fetching an instance, you will receive a database-engine\n(sqlalchemy.engine.base.Engine) for the specified database instance.\nYou can request one like so:\n\n\n# Fetch the default driver, or by name\nengine = app.database()\nengine = app.database(name='mysql')\n\n\n\n\nFetching a session can be done with \ndatabase_session\n. You will receive a\nSession-class (sqlalchemy.orm.scoping.scoped_session) for session-usage:\n\n\nSession = app.database_session()\nSession = app.database_session(name='mysql')\n\nSession.add(user)\nSession.commit()\n\n\n\n\nFurther usage of the database-engine and -session are described in the\nSQLAlchemy documentation:\n\n \nFlask-SQLAlchemy\n\n\n \nSQLAlchemy - Working with Engines and Connections\n\n* \nSQLAlchemy - Session Basics",
            "title": "Database"
        },
        {
            "location": "/data/database/#database",
            "text": "Database usage is built in in Edmunds and uses Flask-SQLAlchemy .",
            "title": "Database"
        },
        {
            "location": "/data/database/#settings",
            "text": "You can set your database preferences in the settings:  from edmunds.database.drivers.mysql import MySql\nfrom edmunds.database.drivers.postgresql import PostgreSql\nfrom edmunds.database.drivers.sqlite import Sqlite\n\nAPP = {\n    'database':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'mysql',\n                'driver': MySql,\n                'user': 'root',\n                'pass': 'root',\n                'host': 'localhost',\n                'database': 'edmunds',\n                # 'port': '3306',   # Optional, default: '3306'\n            },\n            {\n                'name': 'postgresql',\n                'driver': PostgreSql,\n                'user': 'root',\n                'pass': 'root',\n                'host': 'localhost',\n                'database': 'edmunds',\n                # 'port': '5432',   # Optional, default: '5432'\n            },\n            {\n                'name': 'sqlite',\n                'driver': Sqlite,\n                'file': 'sqlite.db',\n                # 'storage': 'storage_name',    # Optional, default storage used as default\n            },\n        ],\n    },\n}  The instances can be used for database, so you can have multiple at once.\nThe first one will be used by default.  The available drivers are:\n-  MySql : For MySQL databases.\n-  PostgreSql : For PostgreSQL databases.\n-  SQLite : For SQLite databases.   More in detail: the default instance will be used as  SQLALCHEMY_DATABASE_URI \nin SQLAlchemy. Other instances (not including the default instance) will\nbe added to  SQLALCHEMY_BINDS .",
            "title": "Settings"
        },
        {
            "location": "/data/database/#usage",
            "text": "When fetching an instance, you will receive a database-engine\n(sqlalchemy.engine.base.Engine) for the specified database instance.\nYou can request one like so:  # Fetch the default driver, or by name\nengine = app.database()\nengine = app.database(name='mysql')  Fetching a session can be done with  database_session . You will receive a\nSession-class (sqlalchemy.orm.scoping.scoped_session) for session-usage:  Session = app.database_session()\nSession = app.database_session(name='mysql')\n\nSession.add(user)\nSession.commit()  Further usage of the database-engine and -session are described in the\nSQLAlchemy documentation:   Flask-SQLAlchemy    SQLAlchemy - Working with Engines and Connections \n*  SQLAlchemy - Session Basics",
            "title": "Usage"
        },
        {
            "location": "/data/migrations/",
            "text": "Migrations\n\n\nDatabase migrations are built in in Edmunds using Flask-Migrate.\n\n\nUsage\n\n\nEdmunds has already integrated the db-command in the application's manager.\nYou can use it as described in the Flask-Migrate-documentation:\n\n\npython manage.py db --help\n\n# Init for your project:\npython manage.py db init --multidb\n# Migrate the changes:\npython manage.py db migrate -m \"Added some tables\"\n# Upgrade the databases:\npython manage.py db upgrade\n\n\n\n\nUsage of Flask-Migrate documentation:\n* \nFlask-Migrate\n\n\nTables\n\n\nTables of SQLAlchemy are used by Flask-Migrate to describe your database\nstructure. Add your table to \napp.database.tables\n so they are picked up\nby the migration-service:\n\n\n# app/database/tables/userstable.py\nfrom edmunds.database.table import Table, Column, Integer, String\nUsersTable = Table('users',\n                   Column('id', Integer, primary_key=True),\n                   Column('name', String(50)),\n                   # info={'bind_key': 'users_database'},\n                   )\n\n# app/database/tables/tagstable.py\nfrom edmunds.database.table import Table, Column, Integer, String\nTagsTable = Table('tags',\n                  Column('id', Integer, primary_key=True),\n                  Column('name', String(50), unique=True),\n                  # info={'bind_key': 'users_database'}\n                  )\n\n# app/database/tables/usertagstable.py\nfrom edmunds.database.table import Table, Column, Integer, ForeignKey\nUserTagsTable = Table('user_tags',\n                      Column('user_id', Integer, ForeignKey('tags.id'), primary_key=True),\n                      Column('tag_id', Integer, ForeignKey('users.id'), primary_key=True),\n                      # info={'bind_key': 'users_database'}\n                      )\n\n\n\n\nFurther documentation on how to declare your tables can be found here:\n\n \nSQLAlchemy Schema Definition Language\n\n\n \nMultiple Databases (binds)\n\n\n\n\nNote: If you want to customize the package where the migrate-service looks\nfor tables, you can override it in your config:\n\npython\nAPP = {\n    'database': {\n        # ...\n        'tables': {\n            'my/location/to/the/tables',\n            'second/location/to/other/tables',\n        },\n    },\n}\n\nThe described paths are relative to the root-folder of your application.",
            "title": "Migrations"
        },
        {
            "location": "/data/migrations/#migrations",
            "text": "Database migrations are built in in Edmunds using Flask-Migrate.",
            "title": "Migrations"
        },
        {
            "location": "/data/migrations/#usage",
            "text": "Edmunds has already integrated the db-command in the application's manager.\nYou can use it as described in the Flask-Migrate-documentation:  python manage.py db --help\n\n# Init for your project:\npython manage.py db init --multidb\n# Migrate the changes:\npython manage.py db migrate -m \"Added some tables\"\n# Upgrade the databases:\npython manage.py db upgrade  Usage of Flask-Migrate documentation:\n*  Flask-Migrate",
            "title": "Usage"
        },
        {
            "location": "/data/migrations/#tables",
            "text": "Tables of SQLAlchemy are used by Flask-Migrate to describe your database\nstructure. Add your table to  app.database.tables  so they are picked up\nby the migration-service:  # app/database/tables/userstable.py\nfrom edmunds.database.table import Table, Column, Integer, String\nUsersTable = Table('users',\n                   Column('id', Integer, primary_key=True),\n                   Column('name', String(50)),\n                   # info={'bind_key': 'users_database'},\n                   )\n\n# app/database/tables/tagstable.py\nfrom edmunds.database.table import Table, Column, Integer, String\nTagsTable = Table('tags',\n                  Column('id', Integer, primary_key=True),\n                  Column('name', String(50), unique=True),\n                  # info={'bind_key': 'users_database'}\n                  )\n\n# app/database/tables/usertagstable.py\nfrom edmunds.database.table import Table, Column, Integer, ForeignKey\nUserTagsTable = Table('user_tags',\n                      Column('user_id', Integer, ForeignKey('tags.id'), primary_key=True),\n                      Column('tag_id', Integer, ForeignKey('users.id'), primary_key=True),\n                      # info={'bind_key': 'users_database'}\n                      )  Further documentation on how to declare your tables can be found here:   SQLAlchemy Schema Definition Language    Multiple Databases (binds)   Note: If you want to customize the package where the migrate-service looks\nfor tables, you can override it in your config: python\nAPP = {\n    'database': {\n        # ...\n        'tables': {\n            'my/location/to/the/tables',\n            'second/location/to/other/tables',\n        },\n    },\n} \nThe described paths are relative to the root-folder of your application.",
            "title": "Tables"
        },
        {
            "location": "/data/orm/",
            "text": "ORM\n\n\nObject-Relational Mapping is implemented using\n\nFlask-SQLAlchemy\n.\n\n\nEdmunds uses the 'Classical Mappings'-way of SQLAlchemy. Here you define\nyour tables and model separately and map them together afterwards. This\ngives you more freedom.\n\n\nDefining and mapping models\n\n\nFirst off you need to define your models. After defining the model-class\nyou can map it to the table using the \nmapper\n:\n\n\nfrom app.database.tables.userstable import UsersTable\nfrom app.database.tables.tagstable import TagsTable\nfrom app.database.tables.userstagstable import UserTagsTable\nfrom edmunds.database.model import Model, mapper, relationship\n\n# app/database/models/user.py\nfrom app.database.models.tag import Tag\n\nclass User(Model):\n    __table__ = UsersTable\n\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return '<User name=\"%s\" id=\"%s\"/>' % (self.name, self.id)\n\nmapper(User, UsersTable, properties={\n    'tags': relationship(Tag, backref='users', secondary=UserTagsTable)\n})\n\n# app/database/models/tag.py\nclass Tag(Model):\n    __table__ = TagsTable\n\n    def __init__(self, name):\n        self.name = name\n\nmapper(Tag, TagsTable)\n\n\n\n\nInsert, Update, Delete\n\n\nThe actions work the same way as Flask-SQLAlchemy does:\n\n\nsession = User.session()\npeter = User(name='peter')\n\n# Inserting\nsession.add(peter)\nsession.commit()\nprint peter.id\n\n# Updating\npeter.name = 'peter verkest'\nsession.commit()\n\n# Deleting\nsession.delete(peter)\nsession.commit()\n\n\n\n\nFurther documentation:\n\n \nFlask-SQLAlchemy Select, Insert, Delete\n\n\n \nSQLAlchemy Adding and Updating Objects\n\n\n\n\nNote: These actions are handy, but not efficient when running in bulk.\nTake a look at this \nStackOverflow-question\n.\n\n\n\n\nQuerying\n\n\nQuerying works the same way as defined in Flask-SQLAlchemy, with the small\ndifference that the \nquery\n-class-property is now a class-method. This is\nso you can query on different database-instance if required. By default\nthe database-instance defined in \nbind_key\n of the \n__table__\n-table is\nused. The second fallback is the default database-instance.\n\n\nusers = User.query().all()  # Would default to UsersTable.info['bind_key'] or default instance\npeter = User.query(name='mysql').filter_by(name='peter').first()  # Uses database-instance with name 'mysql'\n\n\n\n\nFurther documentation on querying:\n\n \nFlask-SQLAlchemy Querying Records\n\n\n \nSQLAlchemy Querying\n\n\n\n\nTip: \nModelClass.session()\n works the same way as \nModelClass.query()\n\ndoes, but returns the result of \napp.database_session()\n with the given\ndatabase-instance by name.",
            "title": "ORM"
        },
        {
            "location": "/data/orm/#orm",
            "text": "Object-Relational Mapping is implemented using Flask-SQLAlchemy .  Edmunds uses the 'Classical Mappings'-way of SQLAlchemy. Here you define\nyour tables and model separately and map them together afterwards. This\ngives you more freedom.",
            "title": "ORM"
        },
        {
            "location": "/data/orm/#defining-and-mapping-models",
            "text": "First off you need to define your models. After defining the model-class\nyou can map it to the table using the  mapper :  from app.database.tables.userstable import UsersTable\nfrom app.database.tables.tagstable import TagsTable\nfrom app.database.tables.userstagstable import UserTagsTable\nfrom edmunds.database.model import Model, mapper, relationship\n\n# app/database/models/user.py\nfrom app.database.models.tag import Tag\n\nclass User(Model):\n    __table__ = UsersTable\n\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return '<User name=\"%s\" id=\"%s\"/>' % (self.name, self.id)\n\nmapper(User, UsersTable, properties={\n    'tags': relationship(Tag, backref='users', secondary=UserTagsTable)\n})\n\n# app/database/models/tag.py\nclass Tag(Model):\n    __table__ = TagsTable\n\n    def __init__(self, name):\n        self.name = name\n\nmapper(Tag, TagsTable)",
            "title": "Defining and mapping models"
        },
        {
            "location": "/data/orm/#insert-update-delete",
            "text": "The actions work the same way as Flask-SQLAlchemy does:  session = User.session()\npeter = User(name='peter')\n\n# Inserting\nsession.add(peter)\nsession.commit()\nprint peter.id\n\n# Updating\npeter.name = 'peter verkest'\nsession.commit()\n\n# Deleting\nsession.delete(peter)\nsession.commit()  Further documentation:   Flask-SQLAlchemy Select, Insert, Delete    SQLAlchemy Adding and Updating Objects   Note: These actions are handy, but not efficient when running in bulk.\nTake a look at this  StackOverflow-question .",
            "title": "Insert, Update, Delete"
        },
        {
            "location": "/data/orm/#querying",
            "text": "Querying works the same way as defined in Flask-SQLAlchemy, with the small\ndifference that the  query -class-property is now a class-method. This is\nso you can query on different database-instance if required. By default\nthe database-instance defined in  bind_key  of the  __table__ -table is\nused. The second fallback is the default database-instance.  users = User.query().all()  # Would default to UsersTable.info['bind_key'] or default instance\npeter = User.query(name='mysql').filter_by(name='peter').first()  # Uses database-instance with name 'mysql'  Further documentation on querying:   Flask-SQLAlchemy Querying Records    SQLAlchemy Querying   Tip:  ModelClass.session()  works the same way as  ModelClass.query() \ndoes, but returns the result of  app.database_session()  with the given\ndatabase-instance by name.",
            "title": "Querying"
        },
        {
            "location": "/data/caching/",
            "text": "Caching\n\n\nCache usage is built in in Edmunds and uses\n\nWerkzeug Cache\n.\n\n\nSettings\n\n\nYou can set your caching preferences in the settings:\n\n\nfrom edmunds.cache.drivers.file import File\nfrom edmunds.cache.drivers.memcached import Memcached\nfrom edmunds.cache.drivers.redis import Redis\n\nAPP = {\n    'cache':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': '',          # Optional, default: '' (= logs/)\n                # 'threshold': 500,         # Optional, default: 500\n                # 'default_timeout': 300,   # Optional, default: 300\n                # 'mode': 0o600,            # Optional, default: 0o600\n            },\n            {\n                'name': 'memcached',\n                'driver': Memcached,\n                # 'servers': ['127.0.0.1:11211'],   # Optional, default: ['127.0.0.1:11211']\n                # 'default_timeout': 300,           # Optional, default: 300\n                # 'key_prefix': None,               # Optional, default: None\n            },\n            {\n                'name': 'redis',\n                'driver': Redis,\n                # 'host': 'localhost',      # Optional, default: 'localhost'\n                # 'port': 6379,             # Optional, default: 6379\n                # 'password': None,         # Optional, default: None\n                # 'db': 0,                  # Optional, default: 0\n                # 'default_timeout': 300,   # Optional, default: 300\n                # 'key_prefix': None,       # Optional, default: None\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances can be used for database, so you can have multiple at once.\nThe first one will be used by default.\n\n\nThe available drivers are:\n- \nFile\n: For caching using files.\n- \nMemcached\n: For Memcached caching.\n- \nRedis\n: For Redis caching.\n\n\nThis configuration is based off the original arguments of the Werkzeug cache\ndrivers. So more information regarding configuration can be found in the\nWerkzeug documentation:\n* \nWerkzeug Cache\n\n\nUsage\n\n\nWhen fetching an instance, you will receive a cache-driver\n(werkzeug.contrib.cache.BaseCache) for the specified cache instance.\nYou can request one like so:\n\n\n# Fetch the default driver, or by name\ndriver = app.cache()\ndriver = app.cache(name='memcached')\n\n\n\n\nFurther usage of the cache-driver is described in the Werkzeug documentation:\n* \nWerkzeug Cache",
            "title": "Caching"
        },
        {
            "location": "/data/caching/#caching",
            "text": "Cache usage is built in in Edmunds and uses Werkzeug Cache .",
            "title": "Caching"
        },
        {
            "location": "/data/caching/#settings",
            "text": "You can set your caching preferences in the settings:  from edmunds.cache.drivers.file import File\nfrom edmunds.cache.drivers.memcached import Memcached\nfrom edmunds.cache.drivers.redis import Redis\n\nAPP = {\n    'cache':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': '',          # Optional, default: '' (= logs/)\n                # 'threshold': 500,         # Optional, default: 500\n                # 'default_timeout': 300,   # Optional, default: 300\n                # 'mode': 0o600,            # Optional, default: 0o600\n            },\n            {\n                'name': 'memcached',\n                'driver': Memcached,\n                # 'servers': ['127.0.0.1:11211'],   # Optional, default: ['127.0.0.1:11211']\n                # 'default_timeout': 300,           # Optional, default: 300\n                # 'key_prefix': None,               # Optional, default: None\n            },\n            {\n                'name': 'redis',\n                'driver': Redis,\n                # 'host': 'localhost',      # Optional, default: 'localhost'\n                # 'port': 6379,             # Optional, default: 6379\n                # 'password': None,         # Optional, default: None\n                # 'db': 0,                  # Optional, default: 0\n                # 'default_timeout': 300,   # Optional, default: 300\n                # 'key_prefix': None,       # Optional, default: None\n            },\n        ],\n    },\n}  The instances can be used for database, so you can have multiple at once.\nThe first one will be used by default.  The available drivers are:\n-  File : For caching using files.\n-  Memcached : For Memcached caching.\n-  Redis : For Redis caching.  This configuration is based off the original arguments of the Werkzeug cache\ndrivers. So more information regarding configuration can be found in the\nWerkzeug documentation:\n*  Werkzeug Cache",
            "title": "Settings"
        },
        {
            "location": "/data/caching/#usage",
            "text": "When fetching an instance, you will receive a cache-driver\n(werkzeug.contrib.cache.BaseCache) for the specified cache instance.\nYou can request one like so:  # Fetch the default driver, or by name\ndriver = app.cache()\ndriver = app.cache(name='memcached')  Further usage of the cache-driver is described in the Werkzeug documentation:\n*  Werkzeug Cache",
            "title": "Usage"
        },
        {
            "location": "/localization/localization/",
            "text": "Localization\n\n\nLocalization is used to tailor an experience for the user that is totally\ncustomized to his/her language, unit-system, currency,...\n\n\nAccuracy in localization is achieved using different sources and factors:\n\n Locale is determined based on (first = highest priority):\n  - Given locale (fixed locale set on client side. given as argument.)\n  - Browser accept languages\n  - User agent\n  - Fallback locale set in config\n\n Location is determined on the client ip address using the given drivers.\n* Time-zone is determined based on (first = highest priority):\n  - Location\n  - Fallback time-zone set in config\n\n\nThe locale will determine how values are formatted and which translations\nare shown to the user. The locales are processed for usage and will comply\nto the following rules:\n\n Locales specifying a region will also be processed without region\n(nl_NL => nl_NL, nl)\n\n Only supported locales will be used.\n\n\nConfiguration\n\n\nThis is an example configuration. See related localization-documentation for\nmore information.\n\n\nfrom edmunds.localization.location.drivers.maxmindcitydatabase import MaxMindCityDatabase\nfrom edmunds.localization.translations.drivers.configtranslator import ConfigTranslator\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'location': {\n            'enabled': True,\n            'instances': [\n                {\n                    'name': 'maxmindcitydb',\n                    'driver': MaxMindCityDatabase,\n                    'database': 'maxmind_city_db.mmdb'\n                },\n            ],\n        },\n\n        'translations': {\n            'enabled': True,\n            'instances': [\n                   {\n                    'name': 'configtranslator',\n                    'driver': ConfigTranslator,\n                },\n            ],\n        },\n    },\n}\n\n\n\n\nUsage\n\n\nThe general localization will be shown here. Other usages will be shown in the\nrelated localization-documentation.\n\n\n\n\nNote: Localization will be more accurate when the location of the user\nis available.\n\n\n\n\nfrom edmunds.http.controller import Controller\nfrom datetime import time, date\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n\n        time_str = self._visitor.localizator.time.time(time(14, 3, 2))\n        date_str = self._visitor.localizator.time.date(date(1992, 6, 7))\n        # ...\n        cost = self._visitor.localizator.number.currency(4.56, 'EUR')\n        number = self._visitor.localizator.number.number(3456.64)\n        # ...\n        is_rtl = self._visitor.localizator.rtl\n        locale = self._visitor.localizator.locale\n        # ...\n\n\n        # Usage through the app/manager\n\n        localization_manager = self._app.localization()\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self._request.remote_addr)\n        localizator_model = localization_manager.localizator(location)\n\n        time_str = localizator_model.time.time(time(14, 3, 2))\n        date_str = localizator_model.time.date(date(1992, 6, 7))\n        # ...\n        cost = localizator_model.number.currency(4.56, 'EUR')\n        number = localizator_model.number.number(3456.64)\n        # ...\n        is_rtl = localizator_model.rtl\n        locale = localizator_model.locale\n        # ...",
            "title": "Localization"
        },
        {
            "location": "/localization/localization/#localization",
            "text": "Localization is used to tailor an experience for the user that is totally\ncustomized to his/her language, unit-system, currency,...  Accuracy in localization is achieved using different sources and factors:  Locale is determined based on (first = highest priority):\n  - Given locale (fixed locale set on client side. given as argument.)\n  - Browser accept languages\n  - User agent\n  - Fallback locale set in config  Location is determined on the client ip address using the given drivers.\n* Time-zone is determined based on (first = highest priority):\n  - Location\n  - Fallback time-zone set in config  The locale will determine how values are formatted and which translations\nare shown to the user. The locales are processed for usage and will comply\nto the following rules:  Locales specifying a region will also be processed without region\n(nl_NL => nl_NL, nl)  Only supported locales will be used.",
            "title": "Localization"
        },
        {
            "location": "/localization/localization/#configuration",
            "text": "This is an example configuration. See related localization-documentation for\nmore information.  from edmunds.localization.location.drivers.maxmindcitydatabase import MaxMindCityDatabase\nfrom edmunds.localization.translations.drivers.configtranslator import ConfigTranslator\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'location': {\n            'enabled': True,\n            'instances': [\n                {\n                    'name': 'maxmindcitydb',\n                    'driver': MaxMindCityDatabase,\n                    'database': 'maxmind_city_db.mmdb'\n                },\n            ],\n        },\n\n        'translations': {\n            'enabled': True,\n            'instances': [\n                   {\n                    'name': 'configtranslator',\n                    'driver': ConfigTranslator,\n                },\n            ],\n        },\n    },\n}",
            "title": "Configuration"
        },
        {
            "location": "/localization/localization/#usage",
            "text": "The general localization will be shown here. Other usages will be shown in the\nrelated localization-documentation.   Note: Localization will be more accurate when the location of the user\nis available.   from edmunds.http.controller import Controller\nfrom datetime import time, date\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n\n        time_str = self._visitor.localizator.time.time(time(14, 3, 2))\n        date_str = self._visitor.localizator.time.date(date(1992, 6, 7))\n        # ...\n        cost = self._visitor.localizator.number.currency(4.56, 'EUR')\n        number = self._visitor.localizator.number.number(3456.64)\n        # ...\n        is_rtl = self._visitor.localizator.rtl\n        locale = self._visitor.localizator.locale\n        # ...\n\n\n        # Usage through the app/manager\n\n        localization_manager = self._app.localization()\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self._request.remote_addr)\n        localizator_model = localization_manager.localizator(location)\n\n        time_str = localizator_model.time.time(time(14, 3, 2))\n        date_str = localizator_model.time.date(date(1992, 6, 7))\n        # ...\n        cost = localizator_model.number.currency(4.56, 'EUR')\n        number = localizator_model.number.number(3456.64)\n        # ...\n        is_rtl = localizator_model.rtl\n        locale = localizator_model.locale\n        # ...",
            "title": "Usage"
        },
        {
            "location": "/localization/location/",
            "text": "Location\n\n\nThis documentation describes how the location of a user can be fetched by ip.\n\n\nConfiguration\n\n\nfrom edmunds.localization.location.drivers.maxmindcitydatabase import MaxMindCityDatabase\nfrom edmunds.localization.location.drivers.maxmindenterprisedatabase import MaxMindEnterpriseDatabase\nfrom edmunds.localization.location.drivers.maxmindwebservice import MaxMindWebService\nfrom edmunds.localization.location.drivers.googleappengine import GoogleAppEngine\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'location': {\n            'enabled': True,\n            'instances': [\n                {\n                    'name': 'gae',\n                    'driver': GoogleAppEngine,\n                },\n                {\n                    'name': 'maxmindcitydb',\n                    'driver': MaxMindCityDatabase,\n                    'database': 'maxmind_city_db.mmdb'\n                },\n                {\n                    'name': 'maxmindenterprisedb',\n                    'driver': MaxMindEnterpriseDatabase,\n                    'database': 'maxmind_enterprise_db.mmdb'\n                },\n                {\n                    'name': 'maxmindweb',\n                    'driver': MaxMindWebService,\n                    'user_id': '1',\n                    'license_key': 'license_key'\n                },\n            ],\n        },\n    },\n}\n\n\n\n\nThe available drivers are:\n- \nMaxMindCityDatabase\n: Using MaxMind City Database\n- \nMaxMindEnterpriseDatabase\n: Using MaxMind Enterprise Database\n- \nMaxMindWebService\n: Using MaxMind Web Service\n- \nGoogleAppEngine\n: Based on specific Google App Engine headers\n\n\nUsage\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n        # Note: Visitor will use the first location driver!\n\n        country_iso = self._visitor.location.country.iso_code\n        city_name = self._visitor.location.city.name\n        # ...\n\n\n        # Usage through the app/manager\n\n        localization_manager = self._app.localization()\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self._request.remote_addr)\n\n        country_iso = location.country.iso_code\n        city_name = location.city.name\n        # ...",
            "title": "Location"
        },
        {
            "location": "/localization/location/#location",
            "text": "This documentation describes how the location of a user can be fetched by ip.",
            "title": "Location"
        },
        {
            "location": "/localization/location/#configuration",
            "text": "from edmunds.localization.location.drivers.maxmindcitydatabase import MaxMindCityDatabase\nfrom edmunds.localization.location.drivers.maxmindenterprisedatabase import MaxMindEnterpriseDatabase\nfrom edmunds.localization.location.drivers.maxmindwebservice import MaxMindWebService\nfrom edmunds.localization.location.drivers.googleappengine import GoogleAppEngine\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'location': {\n            'enabled': True,\n            'instances': [\n                {\n                    'name': 'gae',\n                    'driver': GoogleAppEngine,\n                },\n                {\n                    'name': 'maxmindcitydb',\n                    'driver': MaxMindCityDatabase,\n                    'database': 'maxmind_city_db.mmdb'\n                },\n                {\n                    'name': 'maxmindenterprisedb',\n                    'driver': MaxMindEnterpriseDatabase,\n                    'database': 'maxmind_enterprise_db.mmdb'\n                },\n                {\n                    'name': 'maxmindweb',\n                    'driver': MaxMindWebService,\n                    'user_id': '1',\n                    'license_key': 'license_key'\n                },\n            ],\n        },\n    },\n}  The available drivers are:\n-  MaxMindCityDatabase : Using MaxMind City Database\n-  MaxMindEnterpriseDatabase : Using MaxMind Enterprise Database\n-  MaxMindWebService : Using MaxMind Web Service\n-  GoogleAppEngine : Based on specific Google App Engine headers",
            "title": "Configuration"
        },
        {
            "location": "/localization/location/#usage",
            "text": "from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n        # Note: Visitor will use the first location driver!\n\n        country_iso = self._visitor.location.country.iso_code\n        city_name = self._visitor.location.city.name\n        # ...\n\n\n        # Usage through the app/manager\n\n        localization_manager = self._app.localization()\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self._request.remote_addr)\n\n        country_iso = location.country.iso_code\n        city_name = location.city.name\n        # ...",
            "title": "Usage"
        },
        {
            "location": "/localization/formatting/",
            "text": "Formatting\n\n\nFormatting of values is mandatory when localizing your application. One thousand\nthree hundred forty five point twenty two is not written the same everywhere:\n1,345.22 ; 1.345,22 ; 1345,22 ; ... Also time should be formatted to the users\ntime-zone.\n\n\nConfiguration\n\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n    },\n}\n\n\n\n\nUsage\n\n\nfrom edmunds.http.controller import Controller\nfrom datetime import time, date, datetime\nfrom edmunds.localization.localization.models.time import Time\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n\n        formatted_integer = self._visitor.localizator.number.number(1345)\n        formatted_decimal = self._visitor.localizator.number.number(1345.22)\n        formatted_currency = self._visitor.localizator.number.currency(1345.22, 'EUR')\n        formatted_percentage = self._visitor.localizator.number.percent(0.35)\n        formatted_scientific = self._visitor.localizator.number.scientific(232339)\n        formatted_rtl = self._visitor.localizator.rtl\n        # ...\n\n\n        # Usage through the app/manager\n\n        # Localization manager\n        localization_manager = self._app.localization()\n        # Location\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self._request.remote_addr)\n        # Translator\n        translator = localization_manager.translator()\n        # Localizator\n        localizator = localization_manager.localizator(location, translator)\n\n        formatted_time = localizator.time.time(time(22, 26, 12))\n        formatted_time = localizator.time.time(time(22, 26, 12), format=Time.LONG)\n        formatted_date = localizator.time.date(date(2017, 9, 18))\n        formatted_date = localizator.time.date(date(2017, 9, 18), format=Time.SHORT)\n        formatted_date = localizator.time.date(date(2017, 9, 18), format=Time.FULL)\n        formatted_datetime = localizator.time.datetime(datetime(2017, 9, 18, 22, 26, 12))\n        # ...",
            "title": "Formatting"
        },
        {
            "location": "/localization/formatting/#formatting",
            "text": "Formatting of values is mandatory when localizing your application. One thousand\nthree hundred forty five point twenty two is not written the same everywhere:\n1,345.22 ; 1.345,22 ; 1345,22 ; ... Also time should be formatted to the users\ntime-zone.",
            "title": "Formatting"
        },
        {
            "location": "/localization/formatting/#configuration",
            "text": "APP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n    },\n}",
            "title": "Configuration"
        },
        {
            "location": "/localization/formatting/#usage",
            "text": "from edmunds.http.controller import Controller\nfrom datetime import time, date, datetime\nfrom edmunds.localization.localization.models.time import Time\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n\n        formatted_integer = self._visitor.localizator.number.number(1345)\n        formatted_decimal = self._visitor.localizator.number.number(1345.22)\n        formatted_currency = self._visitor.localizator.number.currency(1345.22, 'EUR')\n        formatted_percentage = self._visitor.localizator.number.percent(0.35)\n        formatted_scientific = self._visitor.localizator.number.scientific(232339)\n        formatted_rtl = self._visitor.localizator.rtl\n        # ...\n\n\n        # Usage through the app/manager\n\n        # Localization manager\n        localization_manager = self._app.localization()\n        # Location\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self._request.remote_addr)\n        # Translator\n        translator = localization_manager.translator()\n        # Localizator\n        localizator = localization_manager.localizator(location, translator)\n\n        formatted_time = localizator.time.time(time(22, 26, 12))\n        formatted_time = localizator.time.time(time(22, 26, 12), format=Time.LONG)\n        formatted_date = localizator.time.date(date(2017, 9, 18))\n        formatted_date = localizator.time.date(date(2017, 9, 18), format=Time.SHORT)\n        formatted_date = localizator.time.date(date(2017, 9, 18), format=Time.FULL)\n        formatted_datetime = localizator.time.datetime(datetime(2017, 9, 18, 22, 26, 12))\n        # ...",
            "title": "Usage"
        },
        {
            "location": "/localization/translations/",
            "text": "Translations\n\n\nTranslations and user experience go hand in hand like cookies and milk.\nThat's why Edmunds helps you out when it comes down to translating.\n\n\nSentences used in translations are dynamically constructed using parameters,\nthe plural-function and the gender-function.\n\n Parameters will be filled in as given and formatted when in the correct format (integer and float as number,\ntime and date and datetime as time. string will remain untouched.).\n\n The plural-function lets you print plurals which is different depending on\nthe locale (see babel.messages.plurals).\n* The gender-function helps you print out possessive pronouns, or gender-bound\nwords or verbs depending on the context.\n\n\nConfiguration\n\n\nfrom edmunds.localization.translations.drivers.configtranslator import ConfigTranslator\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'translations': {\n            'enabled': True,\n            'instances': [\n                   {\n                    'name': 'configtranslator',\n                    'driver': ConfigTranslator,\n                },\n            ],\n\n            # The ConfigTranslator uses configuration to fetch the translations.\n            #   To keep the config clean, try splitting the translations up in\n            #   different config files.\n            #   More on how to format these sentences below.\n            'strings': {\n                'en': {\n                    'beautiful': 'This is a beautiful translation in en. Is it not, {name}?',\n                    'smashing': 'A smashing sentence in en!',\n                    'liking': 'I\\'m taking a liking to --gender:{user}__him__her--...',\n                },\n                'en_US': {\n                    'beautiful': 'This is a beautiful translation in en_US. Is it not, {name}?',\n                    'smashing': 'A smashing sentence in en_US!',\n                },\n                'nl': {\n                    'beautiful': 'Dit is een prachtige vertaling in nl. Nietwaar, {name}?',\n                },\n            },\n        },\n    },\n}\n\n\n\n\nThe available drivers are:\n- \nConfigTranslator\n: Fetches translations from config\n\n\nUsage\n\n\nConstructing sentences\n\n\n\n\nParams are defined as follows: \n{paramname}\n.\n\n\nFunctions are defined as follows: \n--functionname:{argname1},{argname2}__option 1__option 2--\n\n\nPlural-function: \n--plural:{count}__{count} apple__{count} apples--\n\n\nGender-function: \n--gender:{user}__his apple__her apple--\n\n\nNote: Parameters used as arguments of a function will not be formatted.\n\n\n\n\n\n\n\n\nExamples:\n\n \nThis is a beautiful translation in en. Is it not, {name}?\n\n\n \nA smashing sentence in en!\n\n* \nI'm taking a liking to --gender:{user}__him__her--...\n\n\nUsing translations\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n        # Note: Visitor will use the first location and translation driver!\n\n        sentence = self._visitor.localizator.translate('beautiful', {'name': 'Steve'})\n        # locale 'en':      This is a beautiful translation in en. Is it not, Steve?\n        # locale 'en_US':   This is a beautiful translation in en_US. Is it not, Steve?\n        # locale 'nl':      Dit is een prachtige vertaling in nl. Nietwaar, Steve?\n\n        sentence = self._visitor.localizator.translate('smashing')\n        # locale 'en':      A smashing sentence in en!\n        # locale 'en_US':   A smashing sentence in en_US!\n        # locale 'nl':      A smashing sentence in en!      (using fallback en)\n\n\n        # Usage through the app/manager\n\n        # Localization manager\n        localization_manager = self._app.localization()\n        # Location\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self._request.remote_addr)\n        # Translator\n        translator = localization_manager.translator()\n        # Localizator\n        localizator = localization_manager.localizator(location, translator)\n\n        sentence = localizator.translate('liking', {'user': 'F'})\n        # locale 'en':      I'm taking a liking to her...\n        # locale 'en_US':   I'm taking a liking to her...   (using en without region US)\n        # locale 'nl':      I'm taking a liking to her...   (using fallback en)\n\n        # ...",
            "title": "Translations"
        },
        {
            "location": "/localization/translations/#translations",
            "text": "Translations and user experience go hand in hand like cookies and milk.\nThat's why Edmunds helps you out when it comes down to translating.  Sentences used in translations are dynamically constructed using parameters,\nthe plural-function and the gender-function.  Parameters will be filled in as given and formatted when in the correct format (integer and float as number,\ntime and date and datetime as time. string will remain untouched.).  The plural-function lets you print plurals which is different depending on\nthe locale (see babel.messages.plurals).\n* The gender-function helps you print out possessive pronouns, or gender-bound\nwords or verbs depending on the context.",
            "title": "Translations"
        },
        {
            "location": "/localization/translations/#configuration",
            "text": "from edmunds.localization.translations.drivers.configtranslator import ConfigTranslator\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'translations': {\n            'enabled': True,\n            'instances': [\n                   {\n                    'name': 'configtranslator',\n                    'driver': ConfigTranslator,\n                },\n            ],\n\n            # The ConfigTranslator uses configuration to fetch the translations.\n            #   To keep the config clean, try splitting the translations up in\n            #   different config files.\n            #   More on how to format these sentences below.\n            'strings': {\n                'en': {\n                    'beautiful': 'This is a beautiful translation in en. Is it not, {name}?',\n                    'smashing': 'A smashing sentence in en!',\n                    'liking': 'I\\'m taking a liking to --gender:{user}__him__her--...',\n                },\n                'en_US': {\n                    'beautiful': 'This is a beautiful translation in en_US. Is it not, {name}?',\n                    'smashing': 'A smashing sentence in en_US!',\n                },\n                'nl': {\n                    'beautiful': 'Dit is een prachtige vertaling in nl. Nietwaar, {name}?',\n                },\n            },\n        },\n    },\n}  The available drivers are:\n-  ConfigTranslator : Fetches translations from config",
            "title": "Configuration"
        },
        {
            "location": "/localization/translations/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/localization/translations/#constructing-sentences",
            "text": "Params are defined as follows:  {paramname} .  Functions are defined as follows:  --functionname:{argname1},{argname2}__option 1__option 2--  Plural-function:  --plural:{count}__{count} apple__{count} apples--  Gender-function:  --gender:{user}__his apple__her apple--  Note: Parameters used as arguments of a function will not be formatted.     Examples:   This is a beautiful translation in en. Is it not, {name}?    A smashing sentence in en! \n*  I'm taking a liking to --gender:{user}__him__her--...",
            "title": "Constructing sentences"
        },
        {
            "location": "/localization/translations/#using-translations",
            "text": "from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n        # Note: Visitor will use the first location and translation driver!\n\n        sentence = self._visitor.localizator.translate('beautiful', {'name': 'Steve'})\n        # locale 'en':      This is a beautiful translation in en. Is it not, Steve?\n        # locale 'en_US':   This is a beautiful translation in en_US. Is it not, Steve?\n        # locale 'nl':      Dit is een prachtige vertaling in nl. Nietwaar, Steve?\n\n        sentence = self._visitor.localizator.translate('smashing')\n        # locale 'en':      A smashing sentence in en!\n        # locale 'en_US':   A smashing sentence in en_US!\n        # locale 'nl':      A smashing sentence in en!      (using fallback en)\n\n\n        # Usage through the app/manager\n\n        # Localization manager\n        localization_manager = self._app.localization()\n        # Location\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self._request.remote_addr)\n        # Translator\n        translator = localization_manager.translator()\n        # Localizator\n        localizator = localization_manager.localizator(location, translator)\n\n        sentence = localizator.translate('liking', {'user': 'F'})\n        # locale 'en':      I'm taking a liking to her...\n        # locale 'en_US':   I'm taking a liking to her...   (using en without region US)\n        # locale 'nl':      I'm taking a liking to her...   (using fallback en)\n\n        # ...",
            "title": "Using translations"
        },
        {
            "location": "/testing/gettingstarted/",
            "text": "Testing\n\n\nUnittesting is one of the basic keys to success when it comes down to application-uptime. Testing makes sure the application just works and keeps working after code-changes.\n\n\nCreating tests\n\n\nEvery edmunds-instance has a \nmain_test.py\n in its root which can be run with python. This file states where the tests will be located.\n\n\nAdd your own tests to the \ntest\n-directory and initiate them like so:\n\n\nfrom edmunds.foundation.testing.testcase import TestCase\n\n\nclass MyTest(TestCase):\n    \"\"\"\n    Test my tests\n    \"\"\"\n\n    def set_up(self):\n        \"\"\"\n        Set up the test case\n        \"\"\"\n        super(MyTest, self).set_up()\n\n    def tear_down(self):\n        \"\"\"\n        Tear down the test case\n        \"\"\"\n        super(MyTest, self).tear_down()\n\n    def test_something(self):\n        \"\"\"\n        Test something\n        \"\"\"\n        pass\n\n\n\n\nRunning tests\n\n\nRun your tests in command line with:\n\n\npython main_test.py\n\n\n\n\nAsserting\n\n\nThe \nTestCase\n-class already implements a lot of assertion functions:\n\n\n# a == b\nself.assert_equal(a, b)\n# a != b\nself.assert_not_equal(a, b)\n# bool(x) is True\nself.assert_true(x)\n# bool(x) is False\nself.assert_false(x)\n# a is b\nself.assert_is(a, b)\n# a is not b\nself.assert_is_not(a, b)\n# x is None\nself.assert_is_none(x)\n# x is not None\nself.assert_is_not_none(x)\n# a in b\nself.assert_in(a, b)\n# a not in b\nself.assert_not_in(a, b)\n# isinstance(a, b)\nself.assert_is_instance(a, b)\n# not isinstance(a, b)\nself.assert_not_is_instance(a, b)\n# fun(*args, **kwds) raises exc\nself.assert_raises(exc, fun, *args, **kwds)\n# fun(*args, **kwds) raises exc and the message matches regex r\nself.assert_raises_regexp(exc, r, fun, *args, **kwds)\n# round(a-b, 7) == 0\nself.assert_almost_equal(a, b)\n# round(a-b, 7) != 0\nself.assert_not_almost_equal(a, b)\n# a > b\nself.assert_greater(a, b)\n# a >= b\nself.assert_greater_equal(a, b)\n# a < b\nself.assert_less(a, b)\n# a <= b\nself.assert_less_equal(a, b)\n# r.search(s)\nself.assert_regexp_matches(s, r)\n# not r.search(s)\nself.assert_not_regexp_matches(s, r)\n# sorted(a) == sorted(b) and works with unhashable objs\nself.assert_items_equal(a, b)\n# all the key/value pairs in a exist in b\nself.assert_dict_contains_subset(a, b)\n# strings\nself.assert_multi_line_equal(a, b)\n# sequences\nself.assert_sequence_equal(a, b)\n# lists\nself.assert_list_equal(a, b)\n# tuples\nself.assert_tuple_equal(a, b)\n# sets or frozensets\nself.assert_set_equal(a, b)\n# dicts\nself.assert_dict_equal(a, b)",
            "title": "Getting Started"
        },
        {
            "location": "/testing/gettingstarted/#testing",
            "text": "Unittesting is one of the basic keys to success when it comes down to application-uptime. Testing makes sure the application just works and keeps working after code-changes.",
            "title": "Testing"
        },
        {
            "location": "/testing/gettingstarted/#creating-tests",
            "text": "Every edmunds-instance has a  main_test.py  in its root which can be run with python. This file states where the tests will be located.  Add your own tests to the  test -directory and initiate them like so:  from edmunds.foundation.testing.testcase import TestCase\n\n\nclass MyTest(TestCase):\n    \"\"\"\n    Test my tests\n    \"\"\"\n\n    def set_up(self):\n        \"\"\"\n        Set up the test case\n        \"\"\"\n        super(MyTest, self).set_up()\n\n    def tear_down(self):\n        \"\"\"\n        Tear down the test case\n        \"\"\"\n        super(MyTest, self).tear_down()\n\n    def test_something(self):\n        \"\"\"\n        Test something\n        \"\"\"\n        pass",
            "title": "Creating tests"
        },
        {
            "location": "/testing/gettingstarted/#running-tests",
            "text": "Run your tests in command line with:  python main_test.py",
            "title": "Running tests"
        },
        {
            "location": "/testing/gettingstarted/#asserting",
            "text": "The  TestCase -class already implements a lot of assertion functions:  # a == b\nself.assert_equal(a, b)\n# a != b\nself.assert_not_equal(a, b)\n# bool(x) is True\nself.assert_true(x)\n# bool(x) is False\nself.assert_false(x)\n# a is b\nself.assert_is(a, b)\n# a is not b\nself.assert_is_not(a, b)\n# x is None\nself.assert_is_none(x)\n# x is not None\nself.assert_is_not_none(x)\n# a in b\nself.assert_in(a, b)\n# a not in b\nself.assert_not_in(a, b)\n# isinstance(a, b)\nself.assert_is_instance(a, b)\n# not isinstance(a, b)\nself.assert_not_is_instance(a, b)\n# fun(*args, **kwds) raises exc\nself.assert_raises(exc, fun, *args, **kwds)\n# fun(*args, **kwds) raises exc and the message matches regex r\nself.assert_raises_regexp(exc, r, fun, *args, **kwds)\n# round(a-b, 7) == 0\nself.assert_almost_equal(a, b)\n# round(a-b, 7) != 0\nself.assert_not_almost_equal(a, b)\n# a > b\nself.assert_greater(a, b)\n# a >= b\nself.assert_greater_equal(a, b)\n# a < b\nself.assert_less(a, b)\n# a <= b\nself.assert_less_equal(a, b)\n# r.search(s)\nself.assert_regexp_matches(s, r)\n# not r.search(s)\nself.assert_not_regexp_matches(s, r)\n# sorted(a) == sorted(b) and works with unhashable objs\nself.assert_items_equal(a, b)\n# all the key/value pairs in a exist in b\nself.assert_dict_contains_subset(a, b)\n# strings\nself.assert_multi_line_equal(a, b)\n# sequences\nself.assert_sequence_equal(a, b)\n# lists\nself.assert_list_equal(a, b)\n# tuples\nself.assert_tuple_equal(a, b)\n# sets or frozensets\nself.assert_set_equal(a, b)\n# dicts\nself.assert_dict_equal(a, b)",
            "title": "Asserting"
        }
    ]
}
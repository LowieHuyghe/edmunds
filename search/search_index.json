{
    "docs": [
        {
            "location": "/",
            "text": "Edmunds\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEdmunds is a Flask based framework for building web applications\nwith a firm structure to start from. Edmunds takes away the pain of\nbootstrap code so you can kickoff with the things that really\nmatter.\n\n\nLet's get started!\n\n\nGo to: \nhttps://lowiehuyghe.github.io/edmunds/gettingstarted/afreshstart",
            "title": "Introduction"
        },
        {
            "location": "/#edmunds",
            "text": "Edmunds is a Flask based framework for building web applications\nwith a firm structure to start from. Edmunds takes away the pain of\nbootstrap code so you can kickoff with the things that really\nmatter.",
            "title": "Edmunds"
        },
        {
            "location": "/#lets-get-started",
            "text": "Go to:  https://lowiehuyghe.github.io/edmunds/gettingstarted/afreshstart",
            "title": "Let's get started!"
        },
        {
            "location": "/gettingstarted/afreshstart/",
            "text": "A Fresh Start\n\n\n1. Create a new project\n\n\nLet's first get an Edmunds Instance to kick-start your\nproject. Download it from:\n\n\n\n\nhttps://github.com/LowieHuyghe/edmunds-instance/archive/master.zip\n\n\n\n\nUnzip it, move it and rename it after your project.\n\n\n2. Setup a virtual environment\n\n\nNow setup a virtual environment for your project. If you\nneed some help with that, you can take a look at\n\nThe Hitchhiker's guide to Python\n.\n\n\nNow activate your project's virtual environment.\n\n\n3. Install the dependencies\n\n\nFirst install some required setup packages:\n\n\npip install setuptools_scm\n\n\n\n\nNow install all other dependencies:\n\n\npip install -r requirements.txt\n\n\n\n\n4. Take it for a spin!\n\n\nLet's take it for a spin and run the application:\n\n\npython manage.py run\n\n\n\n\n5. Google App Engine (optional)\n\n\nIf you want to develop for and run in Google App Engine\nyou'll first need to install the \nApp Engine SDK\n.\n\n\nThen install the dependencies in the lib-directory:\n\n\npip install -r requirements.txt -t lib\n\n\n\n\nNow start the development server and you are good to go:\n\n\ndev_appserver.py app.yaml",
            "title": "A Fresh Start"
        },
        {
            "location": "/gettingstarted/afreshstart/#a-fresh-start",
            "text": "",
            "title": "A Fresh Start"
        },
        {
            "location": "/gettingstarted/afreshstart/#1-create-a-new-project",
            "text": "Let's first get an Edmunds Instance to kick-start your\nproject. Download it from:   https://github.com/LowieHuyghe/edmunds-instance/archive/master.zip   Unzip it, move it and rename it after your project.",
            "title": "1. Create a new project"
        },
        {
            "location": "/gettingstarted/afreshstart/#2-setup-a-virtual-environment",
            "text": "Now setup a virtual environment for your project. If you\nneed some help with that, you can take a look at The Hitchhiker's guide to Python .  Now activate your project's virtual environment.",
            "title": "2. Setup a virtual environment"
        },
        {
            "location": "/gettingstarted/afreshstart/#3-install-the-dependencies",
            "text": "First install some required setup packages:  pip install setuptools_scm  Now install all other dependencies:  pip install -r requirements.txt",
            "title": "3. Install the dependencies"
        },
        {
            "location": "/gettingstarted/afreshstart/#4-take-it-for-a-spin",
            "text": "Let's take it for a spin and run the application:  python manage.py run",
            "title": "4. Take it for a spin!"
        },
        {
            "location": "/gettingstarted/afreshstart/#5-google-app-engine-optional",
            "text": "If you want to develop for and run in Google App Engine\nyou'll first need to install the  App Engine SDK .  Then install the dependencies in the lib-directory:  pip install -r requirements.txt -t lib  Now start the development server and you are good to go:  dev_appserver.py app.yaml",
            "title": "5. Google App Engine (optional)"
        },
        {
            "location": "/gettingstarted/configuration/",
            "text": "Configuration\n\n\nThe configuration of the application is managed with\nconfiguration-files and environment-files.\n\n\nConfiguration-files are usually found in the\n\nconfig\n-directory and handle all non-secret config.\nEnvironment-files will be in the root-directory and are\nused for environment-specific and secret config.\n\n\nProcessing\n\n\nThe processing of configuration in Edmunds is slightly\nupgraded from Flask's to make it easier to use. The\noriginal way still works as is. Edmunds merely added\na layer for the developer's comfort.\n\n\nAn example config:\n\n\nAPP_NAME = 'My App'\nAPP = {\n    'database': {\n        'mysql': {\n            'ip': '127.0.0.1',\n            'user': 'mydbuser',\n        }\n    }\n}\n\n\n\n\nThis will be processed to:\n\n\nAPP_NAME = 'My App'\nAPP_DATABASE_MYSQL_IP = '127.0.0.1'\nAPP_DATABASE_MYSQL_USER = 'mydbuser'\n\n\n\n\nWhat will be loaded?\n\n\nAll configuration files in the \nconfig\n-directory will\nbe loaded in an arbitrary order.\n\n\nSecondly environment-configuration will be loaded in\nthe root of the project. More on this below.\n\n\nConfiguration can this way be overwritten. Environment-config\nwill overwrite config of the configuration-files if both\ndefine a value for the same key.\n\n\nFetching\n\n\nFetching configuration can be like accessing the config\nas a dictionary. Or by using the added helper-methods.\nUsing the above defined configuration, we can access the\nconfig like so:\n\n\napp_name = app.config('app.name')\n# or\napp_name = app.config['APP_NAME']\n\ndb_ip = app.config('app.database.mysql.ip')\n# or\ndb_ip = app.config['APP_DATABASE_MYSQL_IP']\n\ndb_user = app.config('app.database.mysql.user')\n# or\ndb_user = app.config['APP_DATABASE_MYSQL_USER']\n\nhas_db_pass = app.config.has('app.database.mysql.pass')\n# or\nhas_db_pass = 'APP_DATABASE_MYSQL_PASS' in app.config\n\n\n\n\nUpdating\n\n\nUpdating values at runtime can be done like this:\n\n\napp.config({\n    'app.database.mysql.ip': 'localhost',\n})\n# or\napp.config['APP_DATABASE_MYSQL_IP'] = 'localhost'\n\n\n\n\nEnvironment configuration\n\n\nSome configuration is specific to the runtime environment.\nIt depends on the machine it is running on, or on the\ncurrent environment (development, production or testing).\nThis configuration is not included in the git-repository,\nwhich makes it ideal for security sensitive configuration\n(like the app-secret-key).\n\n\nThe environment configuration is specified in the\n\n.env.py\n-files in the root of the project. An example\nof an \n.env.py\n-file:\n\n\nSECRET_KEY = 'aFBHjD8SHhqj71LEEmoxc8bLH4lzUTr'\nAPP = {\n    'env': 'development'\n}\n\n\n\n\nThe current environment given in the above example\n(\nAPP_ENV\n) will try to load more specific configuration\nin \n.env.development.py\n. This allows you to use separate\ndatabases or caching (for example) depending on the current\nenvironment. Example of an \n.env.development.py\n-file:\n\n\nDATABASE = {\n    'mysql': {\n        'ip': '172.0.0.1',\n        'user': 'myuser',\n        'pass': 'mypass',\n    },\n}\n\n\n\n\nSpecifying the current environment\n\n\nThe current environment is set with the \nAPP_ENV\n-key.\nThe first way to do this is in the \n.env.py\n-file as\nexplained before. The second way is by settings an\nenvironment-variable \nAPP_ENV\n before running the\napplication. For example:\n\n\nexport APP_ENV=production\n\n\n\n\nThis will load \n.env.production.py\n when running the\napplication.",
            "title": "Configuration"
        },
        {
            "location": "/gettingstarted/configuration/#configuration",
            "text": "The configuration of the application is managed with\nconfiguration-files and environment-files.  Configuration-files are usually found in the config -directory and handle all non-secret config.\nEnvironment-files will be in the root-directory and are\nused for environment-specific and secret config.",
            "title": "Configuration"
        },
        {
            "location": "/gettingstarted/configuration/#processing",
            "text": "The processing of configuration in Edmunds is slightly\nupgraded from Flask's to make it easier to use. The\noriginal way still works as is. Edmunds merely added\na layer for the developer's comfort.  An example config:  APP_NAME = 'My App'\nAPP = {\n    'database': {\n        'mysql': {\n            'ip': '127.0.0.1',\n            'user': 'mydbuser',\n        }\n    }\n}  This will be processed to:  APP_NAME = 'My App'\nAPP_DATABASE_MYSQL_IP = '127.0.0.1'\nAPP_DATABASE_MYSQL_USER = 'mydbuser'",
            "title": "Processing"
        },
        {
            "location": "/gettingstarted/configuration/#what-will-be-loaded",
            "text": "All configuration files in the  config -directory will\nbe loaded in an arbitrary order.  Secondly environment-configuration will be loaded in\nthe root of the project. More on this below.  Configuration can this way be overwritten. Environment-config\nwill overwrite config of the configuration-files if both\ndefine a value for the same key.",
            "title": "What will be loaded?"
        },
        {
            "location": "/gettingstarted/configuration/#fetching",
            "text": "Fetching configuration can be like accessing the config\nas a dictionary. Or by using the added helper-methods.\nUsing the above defined configuration, we can access the\nconfig like so:  app_name = app.config('app.name')\n# or\napp_name = app.config['APP_NAME']\n\ndb_ip = app.config('app.database.mysql.ip')\n# or\ndb_ip = app.config['APP_DATABASE_MYSQL_IP']\n\ndb_user = app.config('app.database.mysql.user')\n# or\ndb_user = app.config['APP_DATABASE_MYSQL_USER']\n\nhas_db_pass = app.config.has('app.database.mysql.pass')\n# or\nhas_db_pass = 'APP_DATABASE_MYSQL_PASS' in app.config",
            "title": "Fetching"
        },
        {
            "location": "/gettingstarted/configuration/#updating",
            "text": "Updating values at runtime can be done like this:  app.config({\n    'app.database.mysql.ip': 'localhost',\n})\n# or\napp.config['APP_DATABASE_MYSQL_IP'] = 'localhost'",
            "title": "Updating"
        },
        {
            "location": "/gettingstarted/configuration/#environment-configuration",
            "text": "Some configuration is specific to the runtime environment.\nIt depends on the machine it is running on, or on the\ncurrent environment (development, production or testing).\nThis configuration is not included in the git-repository,\nwhich makes it ideal for security sensitive configuration\n(like the app-secret-key).  The environment configuration is specified in the .env.py -files in the root of the project. An example\nof an  .env.py -file:  SECRET_KEY = 'aFBHjD8SHhqj71LEEmoxc8bLH4lzUTr'\nAPP = {\n    'env': 'development'\n}  The current environment given in the above example\n( APP_ENV ) will try to load more specific configuration\nin  .env.development.py . This allows you to use separate\ndatabases or caching (for example) depending on the current\nenvironment. Example of an  .env.development.py -file:  DATABASE = {\n    'mysql': {\n        'ip': '172.0.0.1',\n        'user': 'myuser',\n        'pass': 'mypass',\n    },\n}",
            "title": "Environment configuration"
        },
        {
            "location": "/gettingstarted/configuration/#specifying-the-current-environment",
            "text": "The current environment is set with the  APP_ENV -key.\nThe first way to do this is in the  .env.py -file as\nexplained before. The second way is by settings an\nenvironment-variable  APP_ENV  before running the\napplication. For example:  export APP_ENV=production  This will load  .env.production.py  when running the\napplication.",
            "title": "Specifying the current environment"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/",
            "text": "Debugging and Profiling\n\n\nWhen all hell breaks loose or your application is underperforming,\ndebugging and profiling is the answer.\n\n\nDebugging\n\n\nDebugging your application can be done in several ways. Using your\nIDE, \npdb\n, \npudb\n,... There are many options, but here \npdb\n and\n\npudb\n will be explained.\n\n\nPdb\n\n\nPdb, the python debugger\n,\nis a minimal debugger that comes straight out of the box in python.\nIt runs in the terminal and has a minimal interface.\n\n\nStart pdb\n\n\npython -m pdb manage.py run\n\n\n\n\nDebug with pdb\n\n\nAdd breakpoints like so:\n\n\nfrom pdb import set_trace\nset_trace()\n\n\n\n\nMore debug-options can be found in the \ndocumentation\n.\n\n\nPudb\n\n\nPudb\n is a more interactive debugger.\nIt runs in the terminal and has a nice interface which displays the code,\nstack, variables,...\n\n\nInstall pudb\n\n\n\n\nDownload the \ntar.gz\n from \nPyPi\n\n\nRun \n./setup.py install\n\n\n\n\nStart pudb\n\n\npudb manage.py run\n\n\n\n\nDebug with pudb\n\n\nfrom pudb import set_trace\nset_trace()\n\n\n\n\nMore debug-options can be found in the \ndocumentation\n.\n\n\nProfiling\n\n\nEdmunds comes with profiling built in. You can activate it in your settings:\n\n\nfrom edmunds.profiler.drivers.callgraph import CallGraph\nfrom edmunds.profiler.drivers.stream import Stream\nfrom edmunds.profiler.drivers.blackfireio import BlackfireIo\nimport sys\n\nAPP = {\n    'debug': True,\n    'profiler':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'stream',\n                'driver': Stream,\n                # 'stream': sys.stdout,     # Optional, default: sys.stdout\n                # 'sort_by': ('calls'),     # Optional, default: ('time', 'calls')\n                # 'restrictions': (),       # Optional, default: ()\n            },\n            {\n                'name': 'callgraph',\n                'driver': CallGraph,\n                # 'directory': 'profs',     # Optional, default: 'profs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n            {\n                'name': 'blackfireio',\n                'driver': BlackfireIo,\n                # 'directory': 'profs',     # Optional, default: 'profs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances will all be used for profiling, so you can have multiple at once.\n\n\nThe available drivers are:\n\n\n\n\nStream\n: Print output in the given stream.\n\n\nCallGraph\n: Outputs in CallGraph-format to open in a viewer.\n\n\nBlackfireIo\n: Output in BlackfireIo-format to upload to \nBlackfire.io\n.",
            "title": "Debugging and Profiling"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#debugging-and-profiling",
            "text": "When all hell breaks loose or your application is underperforming,\ndebugging and profiling is the answer.",
            "title": "Debugging and Profiling"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#debugging",
            "text": "Debugging your application can be done in several ways. Using your\nIDE,  pdb ,  pudb ,... There are many options, but here  pdb  and pudb  will be explained.",
            "title": "Debugging"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#pdb",
            "text": "Pdb, the python debugger ,\nis a minimal debugger that comes straight out of the box in python.\nIt runs in the terminal and has a minimal interface.",
            "title": "Pdb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#start-pdb",
            "text": "python -m pdb manage.py run",
            "title": "Start pdb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#debug-with-pdb",
            "text": "Add breakpoints like so:  from pdb import set_trace\nset_trace()  More debug-options can be found in the  documentation .",
            "title": "Debug with pdb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#pudb",
            "text": "Pudb  is a more interactive debugger.\nIt runs in the terminal and has a nice interface which displays the code,\nstack, variables,...",
            "title": "Pudb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#install-pudb",
            "text": "Download the  tar.gz  from  PyPi  Run  ./setup.py install",
            "title": "Install pudb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#start-pudb",
            "text": "pudb manage.py run",
            "title": "Start pudb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#debug-with-pudb",
            "text": "from pudb import set_trace\nset_trace()  More debug-options can be found in the  documentation .",
            "title": "Debug with pudb"
        },
        {
            "location": "/gettingstarted/debuggingandprofiling/#profiling",
            "text": "Edmunds comes with profiling built in. You can activate it in your settings:  from edmunds.profiler.drivers.callgraph import CallGraph\nfrom edmunds.profiler.drivers.stream import Stream\nfrom edmunds.profiler.drivers.blackfireio import BlackfireIo\nimport sys\n\nAPP = {\n    'debug': True,\n    'profiler':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'stream',\n                'driver': Stream,\n                # 'stream': sys.stdout,     # Optional, default: sys.stdout\n                # 'sort_by': ('calls'),     # Optional, default: ('time', 'calls')\n                # 'restrictions': (),       # Optional, default: ()\n            },\n            {\n                'name': 'callgraph',\n                'driver': CallGraph,\n                # 'directory': 'profs',     # Optional, default: 'profs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n            {\n                'name': 'blackfireio',\n                'driver': BlackfireIo,\n                # 'directory': 'profs',     # Optional, default: 'profs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n        ],\n    },\n}  The instances will all be used for profiling, so you can have multiple at once.  The available drivers are:   Stream : Print output in the given stream.  CallGraph : Outputs in CallGraph-format to open in a viewer.  BlackfireIo : Output in BlackfireIo-format to upload to  Blackfire.io .",
            "title": "Profiling"
        },
        {
            "location": "/gettingstarted/logginganderrors/",
            "text": "Logging and Errors\n\n\nLogging and error-handling are built in and ready when you are.\n\n\nLogging\n\n\nEdmunds comes with logging built in. You can activate it in your settings:\n\n\nfrom edmunds.log.drivers.file import File\nfrom edmunds.log.drivers.stream import Stream\nfrom edmunds.log.drivers.syslog import SysLog\nfrom edmunds.log.drivers.timedfile import TimedFile\nfrom edmunds.log.drivers.googleappengine import GoogleAppEngine\nfrom logging.handlers import SysLogHandler, SYSLOG_UDP_PORT\nfrom logging import WARNING\nfrom socket import SOCK_DGRAM\nimport sys\n\nAPP = {\n    'logging':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': 'logs',      # Optional, default: 'logs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n                # 'max_bytes': 0,           # Optional, default: 0\n                # 'backup_count': 0,        # Optional, default: 0\n                # 'level': WARNING,         # Optional, default: WARNING\n                # 'format': '%(message)s',  # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'timedfile',\n                'driver': TimedFile,\n                # 'directory': 'logs',                  # Optional, default: 'logs'\n                # 'prefix': 'Myapp.',                   # Optional, default: ''\n                # 'when': 'H',                          # Optional, default: 'D'\n                # 'interval': 12,                       # Optional, default: 1\n                # 'backup_count': 0,                    # Optional, default: 0\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'syslog',\n                'driver': SysLog,\n                # 'address': '/dev/log',                # Optional, default: ('localhost', SYSLOG_UDP_PORT)\n                # 'facility': SysLogHandler.LOG_USER,   # Optional, default: SysLogHandler.LOG_USER\n                # 'socktype': SOCK_DGRAM,               # Optional, default: SOCK_DGRAM\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'stream',\n                'driver': Stream,\n                # 'stream': sys.stderr,                 # Optional, default: sys.stderr\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'googleappengine',\n                'driver': GoogleAppEngine,\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '%(levelname)-8s %(asctime)s %(filename)s:%(lineno)s] %(message)s'\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances will all be used for logging, so you can have multiple at once.\n\n\nThe available drivers are:\n\n\n\n\nFile\n: Print logs to file which can be separated by size.\n\n\nTimedFile\n: Print logs to file which can be separated by time-interval.\n\n\nSysLog\n: Print logs to syslog.\n\n\nStream\n: Pring logs to given stream.\n\n\nGoogleAppEngine\n: Pring logs to the Google App Engine stream when running in Google App Engine runtime.\n\n\n\n\nErrors\n\n\nEven the best programming logic and tests can't always foresee every\npossible scenario where errors can occure. You can report and render\nthese exceptions by registering your own exception-handler.\n\n\nIf logging is enabled, errors that pass through the handler will\nautomatically be logged to your provider logging-services.\n\n\nDefine\n\n\nDefine your Handler like so:\n\n\nfrom edmunds.exceptions.handler import Handler as EdmundsHandler\n\nclass Handler(EdmundsHandler):\n    \"\"\"\n    Exception handler\n    \"\"\"\n\n    def report(self, exception):\n        \"\"\"\n        Report the exception\n        :param exception:   The exception\n        :type  exception:   Exception\n        \"\"\"\n        if super(Handler, self).report(exception):\n            # Additional reporting\n            pass\n\n    def render(self, exception):\n        \"\"\"\n        Render the exception\n        :param exception:   The exception\n        :type  exception:   Exception\n        :return:            The response\n        \"\"\"\n        return super(Handler, self).render(exception)\n\n\n\n\nImportant!\n: The \nreport\n-function of the edmunds-super-class will log\nthe error to \nself.app.logger\n. You defined loggers will by default pick up\ncaught exceptions as described above.\n\n\nRegister\n\n\nRegister the Handler for usage in \nconfig/app.py\n:\n\n\nfrom app.exceptions.handler import Handler\n\nAPP = {\n    'exceptions':\n    {\n        'handler': Handler,\n    },\n}\n\n\n\n\nThis way the application knows to use your handler in case of an exception.",
            "title": "Logging and Errors"
        },
        {
            "location": "/gettingstarted/logginganderrors/#logging-and-errors",
            "text": "Logging and error-handling are built in and ready when you are.",
            "title": "Logging and Errors"
        },
        {
            "location": "/gettingstarted/logginganderrors/#logging",
            "text": "Edmunds comes with logging built in. You can activate it in your settings:  from edmunds.log.drivers.file import File\nfrom edmunds.log.drivers.stream import Stream\nfrom edmunds.log.drivers.syslog import SysLog\nfrom edmunds.log.drivers.timedfile import TimedFile\nfrom edmunds.log.drivers.googleappengine import GoogleAppEngine\nfrom logging.handlers import SysLogHandler, SYSLOG_UDP_PORT\nfrom logging import WARNING\nfrom socket import SOCK_DGRAM\nimport sys\n\nAPP = {\n    'logging':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': 'logs',      # Optional, default: 'logs'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n                # 'max_bytes': 0,           # Optional, default: 0\n                # 'backup_count': 0,        # Optional, default: 0\n                # 'level': WARNING,         # Optional, default: WARNING\n                # 'format': '%(message)s',  # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'timedfile',\n                'driver': TimedFile,\n                # 'directory': 'logs',                  # Optional, default: 'logs'\n                # 'prefix': 'Myapp.',                   # Optional, default: ''\n                # 'when': 'H',                          # Optional, default: 'D'\n                # 'interval': 12,                       # Optional, default: 1\n                # 'backup_count': 0,                    # Optional, default: 0\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'syslog',\n                'driver': SysLog,\n                # 'address': '/dev/log',                # Optional, default: ('localhost', SYSLOG_UDP_PORT)\n                # 'facility': SysLogHandler.LOG_USER,   # Optional, default: SysLogHandler.LOG_USER\n                # 'socktype': SOCK_DGRAM,               # Optional, default: SOCK_DGRAM\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'stream',\n                'driver': Stream,\n                # 'stream': sys.stderr,                 # Optional, default: sys.stderr\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '[%(asctime)s] %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'\n            },\n            {\n                'name': 'googleappengine',\n                'driver': GoogleAppEngine,\n                # 'level': WARNING,                     # Optional, default: WARNING\n                # 'format': '%(message)s',              # Optional, default: '%(levelname)-8s %(asctime)s %(filename)s:%(lineno)s] %(message)s'\n            },\n        ],\n    },\n}  The instances will all be used for logging, so you can have multiple at once.  The available drivers are:   File : Print logs to file which can be separated by size.  TimedFile : Print logs to file which can be separated by time-interval.  SysLog : Print logs to syslog.  Stream : Pring logs to given stream.  GoogleAppEngine : Pring logs to the Google App Engine stream when running in Google App Engine runtime.",
            "title": "Logging"
        },
        {
            "location": "/gettingstarted/logginganderrors/#errors",
            "text": "Even the best programming logic and tests can't always foresee every\npossible scenario where errors can occure. You can report and render\nthese exceptions by registering your own exception-handler.  If logging is enabled, errors that pass through the handler will\nautomatically be logged to your provider logging-services.",
            "title": "Errors"
        },
        {
            "location": "/gettingstarted/logginganderrors/#define",
            "text": "Define your Handler like so:  from edmunds.exceptions.handler import Handler as EdmundsHandler\n\nclass Handler(EdmundsHandler):\n    \"\"\"\n    Exception handler\n    \"\"\"\n\n    def report(self, exception):\n        \"\"\"\n        Report the exception\n        :param exception:   The exception\n        :type  exception:   Exception\n        \"\"\"\n        if super(Handler, self).report(exception):\n            # Additional reporting\n            pass\n\n    def render(self, exception):\n        \"\"\"\n        Render the exception\n        :param exception:   The exception\n        :type  exception:   Exception\n        :return:            The response\n        \"\"\"\n        return super(Handler, self).render(exception)  Important! : The  report -function of the edmunds-super-class will log\nthe error to  self.app.logger . You defined loggers will by default pick up\ncaught exceptions as described above.",
            "title": "Define"
        },
        {
            "location": "/gettingstarted/logginganderrors/#register",
            "text": "Register the Handler for usage in  config/app.py :  from app.exceptions.handler import Handler\n\nAPP = {\n    'exceptions':\n    {\n        'handler': Handler,\n    },\n}  This way the application knows to use your handler in case of an exception.",
            "title": "Register"
        },
        {
            "location": "/gettingstarted/console/",
            "text": "Console\n\n\nConsole usage is built in in Edmunds and uses default Flask CLI.\nEdmunds has wrappers to make usage easier and more organized.\n\n\nFlask CLI uses click to register and use commands. More on this in the\n\nFlask CLI documentation\n.\n\n\n\n\nThe Manager (base: \nedmunds.console.manager\n) is responsible for\nregistering the commands.\n\n\nThe Command (base: \nedmunds.console.command\n) is a wrapper that uses its\n\nrun\n-function as an entry-point for click. Option-decorators can be\ndefined there.\n\n\n\n\nUsage\n\n\nConstruct command\n\n\nCommands are by default located in the \napp.console.commands\n-module.\nAdd command decorators to the \nrun\n-function like you normally would\nwih click.\n\n\nfrom edmunds.console.command import Command\nimport click\n\nclass HelloWorldCommand(Command):\n    \"\"\"\n    Prints Hello World!\n    \"\"\"\n    @click.option('--what', default='World', help='Hello what?')\n    def run(self, what):\n        \"\"\"\n        Run the command\n        :param what:    Hello what?\n        \"\"\"\n        print('Hello %s!' % what)\n\n\n\n\nRegister commands\n\n\nThe manager is by default located in the \napp.console.manager\n-module. \nYou can register your custom commands (located in \napp.console.commands\n)\nin the manager. This will wrap the \nrun\n-function of the command in a\n\nclick.command\n-decorator so its available for console-usage.\n\n\n# ...\nfrom edmunds.console.manager import Manager as EdmundsManager\nfrom app.console.commands.helloworldcommand import HelloWorldCommand\n\nclass Manager(EdmundsManager):\n    # ...\n    def add_commands(self):\n        # ...\n        self.add_command('helloworld', HelloWorldCommand)\n\n\n\n\nConsole usage\n\n\nConsole-usage of your application has been integrated in \nmanage.py\n.\nIt's a wrapper for the \nflask\n-command which requires extra\nenvironment-variables. By default the manager in \napp.console.manager\n\nwill be loaded. You can use \nmanage.py\n by calling it in your\nruntime-environment:\n\n\npython manage.py --help\npython manage.py helloworld",
            "title": "Console"
        },
        {
            "location": "/gettingstarted/console/#console",
            "text": "Console usage is built in in Edmunds and uses default Flask CLI.\nEdmunds has wrappers to make usage easier and more organized.  Flask CLI uses click to register and use commands. More on this in the Flask CLI documentation .   The Manager (base:  edmunds.console.manager ) is responsible for\nregistering the commands.  The Command (base:  edmunds.console.command ) is a wrapper that uses its run -function as an entry-point for click. Option-decorators can be\ndefined there.",
            "title": "Console"
        },
        {
            "location": "/gettingstarted/console/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/gettingstarted/console/#construct-command",
            "text": "Commands are by default located in the  app.console.commands -module.\nAdd command decorators to the  run -function like you normally would\nwih click.  from edmunds.console.command import Command\nimport click\n\nclass HelloWorldCommand(Command):\n    \"\"\"\n    Prints Hello World!\n    \"\"\"\n    @click.option('--what', default='World', help='Hello what?')\n    def run(self, what):\n        \"\"\"\n        Run the command\n        :param what:    Hello what?\n        \"\"\"\n        print('Hello %s!' % what)",
            "title": "Construct command"
        },
        {
            "location": "/gettingstarted/console/#register-commands",
            "text": "The manager is by default located in the  app.console.manager -module. \nYou can register your custom commands (located in  app.console.commands )\nin the manager. This will wrap the  run -function of the command in a click.command -decorator so its available for console-usage.  # ...\nfrom edmunds.console.manager import Manager as EdmundsManager\nfrom app.console.commands.helloworldcommand import HelloWorldCommand\n\nclass Manager(EdmundsManager):\n    # ...\n    def add_commands(self):\n        # ...\n        self.add_command('helloworld', HelloWorldCommand)",
            "title": "Register commands"
        },
        {
            "location": "/gettingstarted/console/#console-usage",
            "text": "Console-usage of your application has been integrated in  manage.py .\nIt's a wrapper for the  flask -command which requires extra\nenvironment-variables. By default the manager in  app.console.manager \nwill be loaded. You can use  manage.py  by calling it in your\nruntime-environment:  python manage.py --help\npython manage.py helloworld",
            "title": "Console usage"
        },
        {
            "location": "/gettingstarted/testing/",
            "text": "Testing\n\n\n\n\nUntested Code is Broken Code\n\n\n\n\nCreating tests\n\n\nAdd your own tests to the \ntests\n-directory and initiate them like so:\n\n\nfrom tests.testcase import TestCase\n\nclass MyTest(TestCase):\n    \"\"\"\n    Test my tests\n    \"\"\"\n\n    def set_up(self):\n        \"\"\"\n        Set up the test case\n        \"\"\"\n        super(MyTest, self).set_up()\n\n    def tear_down(self):\n        \"\"\"\n        Tear down the test case\n        \"\"\"\n        super(MyTest, self).tear_down()\n\n    def test_something(self):\n        \"\"\"\n        Test something\n        \"\"\"\n        pass\n\n\n\n\nRunning tests\n\n\nNose is used for running the tests in the command line. Run them like so:\n\n\npython manage.py test\npython manage.py test --test-suite tests.testmycase\n\n\n\n\nAsserting\n\n\nThe \nTestCase\n-class extends the \nunittest.TestCase\n, but implements the default\nassertion-functions in snake-case format:\n\n\n# a == b\nself.assert_equal(a, b)\n# == self.assertEqual(a, b)\n\n# bool(x) is False\nself.assert_false(x)\n# == self.assertFalse(a, b)\n\n# ...",
            "title": "Testing"
        },
        {
            "location": "/gettingstarted/testing/#testing",
            "text": "Untested Code is Broken Code",
            "title": "Testing"
        },
        {
            "location": "/gettingstarted/testing/#creating-tests",
            "text": "Add your own tests to the  tests -directory and initiate them like so:  from tests.testcase import TestCase\n\nclass MyTest(TestCase):\n    \"\"\"\n    Test my tests\n    \"\"\"\n\n    def set_up(self):\n        \"\"\"\n        Set up the test case\n        \"\"\"\n        super(MyTest, self).set_up()\n\n    def tear_down(self):\n        \"\"\"\n        Tear down the test case\n        \"\"\"\n        super(MyTest, self).tear_down()\n\n    def test_something(self):\n        \"\"\"\n        Test something\n        \"\"\"\n        pass",
            "title": "Creating tests"
        },
        {
            "location": "/gettingstarted/testing/#running-tests",
            "text": "Nose is used for running the tests in the command line. Run them like so:  python manage.py test\npython manage.py test --test-suite tests.testmycase",
            "title": "Running tests"
        },
        {
            "location": "/gettingstarted/testing/#asserting",
            "text": "The  TestCase -class extends the  unittest.TestCase , but implements the default\nassertion-functions in snake-case format:  # a == b\nself.assert_equal(a, b)\n# == self.assertEqual(a, b)\n\n# bool(x) is False\nself.assert_false(x)\n# == self.assertFalse(a, b)\n\n# ...",
            "title": "Asserting"
        },
        {
            "location": "/coreconcepts/applicationmiddleware/",
            "text": "Application Middleware\n\n\nApplication Middleware is the proper way of layering your application.\nMiddleware can be used to add functionality to your application when\nprocessing calls. The middleware gets called each time your application\nis called.\n\n\nDefine\n\n\nDefine your Application Middleware like so:\n\n\nfrom edmunds.foundation.applicationmiddleware import ApplicationMiddleware\n\nclass MyApplicationMiddleware(ApplicationMiddleware):\n    \"\"\"\n    My Application Middleware\n    \"\"\"\n\n    def handle(self, environment, start_response):\n        \"\"\"\n        Handle the middleware\n        :param environment:     The environment\n        :type  environment:     Environment\n        :param start_response:  The response\n        :type  start_response:  Response\n        \"\"\"\n\n        return super(MyApplicationMiddleware, self).handle(environment, start_response)\n\n\n\n\n\n\nNote: Application Middleware is the equivalent of the Flask Middleware using\nwsgi_app-wrappers.\n\n\n\n\nRegister\n\n\nRegister the Application Middleware once it needs to be loaded:\n\n\nfrom app.Foundation.MyApplicationMiddleware import MyApplicationMiddleware\n\napp.middleware(MyApplicationMiddleware)\n\n\n\n\nThis way the handle-function of your Application Middleware is called.\n\n\n\n\nNote: Application Middleware can only be registered once.",
            "title": "Application Middleware"
        },
        {
            "location": "/coreconcepts/applicationmiddleware/#application-middleware",
            "text": "Application Middleware is the proper way of layering your application.\nMiddleware can be used to add functionality to your application when\nprocessing calls. The middleware gets called each time your application\nis called.",
            "title": "Application Middleware"
        },
        {
            "location": "/coreconcepts/applicationmiddleware/#define",
            "text": "Define your Application Middleware like so:  from edmunds.foundation.applicationmiddleware import ApplicationMiddleware\n\nclass MyApplicationMiddleware(ApplicationMiddleware):\n    \"\"\"\n    My Application Middleware\n    \"\"\"\n\n    def handle(self, environment, start_response):\n        \"\"\"\n        Handle the middleware\n        :param environment:     The environment\n        :type  environment:     Environment\n        :param start_response:  The response\n        :type  start_response:  Response\n        \"\"\"\n\n        return super(MyApplicationMiddleware, self).handle(environment, start_response)   Note: Application Middleware is the equivalent of the Flask Middleware using\nwsgi_app-wrappers.",
            "title": "Define"
        },
        {
            "location": "/coreconcepts/applicationmiddleware/#register",
            "text": "Register the Application Middleware once it needs to be loaded:  from app.Foundation.MyApplicationMiddleware import MyApplicationMiddleware\n\napp.middleware(MyApplicationMiddleware)  This way the handle-function of your Application Middleware is called.   Note: Application Middleware can only be registered once.",
            "title": "Register"
        },
        {
            "location": "/coreconcepts/serviceproviders/",
            "text": "Service Providers\n\n\nService Providers are a way of keeping the application as light as possible.\nThis is done by separating your application in modules and only loading the\nmodules you need.\n\n\nAlso the service providers make sure your application is loaded completely\nwhen starting up. So no loading needs to be done while processing requests.\n\n\nDefine\n\n\nDefine your Service Provider like so:\n\n\nfrom edmunds.support.serviceprovider import ServiceProvider\n\nclass MyServiceProvider(ServiceProvider):\n    \"\"\"\n    My Service Provider\n    \"\"\"\n\n    def register(self):\n        \"\"\"\n        Register the service provider\n        \"\"\"\n        # Load in your module\n        pass\n\n\n\n\nRegister\n\n\nRegister the Service Provider once it needs to be loaded:\n\n\nfrom app.Providers.MyServiceProvider import MyServiceProvider\n\napp.register(MyServiceProvider)\n\n\n\n\nThis way the register-function of your Service Provider provider is called.\n\n\n\n\nNote: A Service Provider can only be registered once.",
            "title": "Service Providers"
        },
        {
            "location": "/coreconcepts/serviceproviders/#service-providers",
            "text": "Service Providers are a way of keeping the application as light as possible.\nThis is done by separating your application in modules and only loading the\nmodules you need.  Also the service providers make sure your application is loaded completely\nwhen starting up. So no loading needs to be done while processing requests.",
            "title": "Service Providers"
        },
        {
            "location": "/coreconcepts/serviceproviders/#define",
            "text": "Define your Service Provider like so:  from edmunds.support.serviceprovider import ServiceProvider\n\nclass MyServiceProvider(ServiceProvider):\n    \"\"\"\n    My Service Provider\n    \"\"\"\n\n    def register(self):\n        \"\"\"\n        Register the service provider\n        \"\"\"\n        # Load in your module\n        pass",
            "title": "Define"
        },
        {
            "location": "/coreconcepts/serviceproviders/#register",
            "text": "Register the Service Provider once it needs to be loaded:  from app.Providers.MyServiceProvider import MyServiceProvider\n\napp.register(MyServiceProvider)  This way the register-function of your Service Provider provider is called.   Note: A Service Provider can only be registered once.",
            "title": "Register"
        },
        {
            "location": "/http/routing/",
            "text": "Routing\n\n\nRouting the request has slightly been modified with some inspiration from\nLaravel. The routing of Flask applies, but a minor change has been made\nso controllers can be used.\n\n\nBasic routing\n\n\napp.route('/', uses=(MyController, 'get_index'))\n\n\n\n\nThis will route the request to \nget_index\n in \nMyController\n:\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    \"\"\"\n    My Controller\n    \"\"\"\n\n    def initialize(self, **params):\n        \"\"\"\n        Initialize the controller\n        :param params:      The parameters in the url\n        :type  params:      dict\n        \"\"\"\n        super(MyController, self).initialize()\n\n    def get_index(self):\n        \"\"\"\n        Get the index-page\n        \"\"\"\n        return 'Hello World!'\n\n\n\n\n\nAs you can see there is a method called \ninitialize\n. This method is\nresponsible for initializing the controller.\n\n\nConstructing and initializing the controller is done in this order:\n\n\n\n\nConstruct the controller \n(\n__init__\n)\n\n\nInitialize the controller \n(\ninitialize\n)\n\n\nCall the method and return the response \n(\nget_index\n)\n\n\n\n\nDynamic routing\n\n\nAdding variable parts to a url is done by marking them with special sections:\n\n\napp.route('/user/<username>', uses=(MyController, 'get_user'))\napp.route('/post/<int:post_id>', uses=(MyController, 'get_post')) # Using converters\n\n\n\n\nOther possible converters:\n\n\n\n\nstring\n: accepts any text without a slash (the default)\n\n\nint\n: accepts integers\n\n\nfloat\n: like int but for floating point values\n\n\npath\n: like the default but also accepts slashes\n\n\nany\n: matches one of the items provided\n\n\nuuid\n: accepts UUID strings\n\n\n\n\nThese parameters are catched in the controller as followed:\n\n\ndef get_user(self, username = None):\n        return 'User: %s' % username\n\ndef get_post(self, post_id = None):\n        return 'Post with id: %d' % post_id\n\n\n\n\nAs seen previously, the parameters are also passed to the \ninitialize\n-method.\n\n\nHTTP methods\n\n\nHTTP knows different methods which can be defined in the routes. By default the route will listen to \nGET\n-requests.\n\n\napp.route('/login', uses=(LoginController, 'get_login'), methods = ['GET'])\napp.route('/login', uses=(LoginController, 'post_login'), methods = ['POST'])\n\n\n\n\nAll supported methods:\n\n\n\n\nGET\n\n\nHEAD\n\n\nPOST\n\n\nPUT\n\n\nDELETE\n\n\nOPTIONS",
            "title": "Routing"
        },
        {
            "location": "/http/routing/#routing",
            "text": "Routing the request has slightly been modified with some inspiration from\nLaravel. The routing of Flask applies, but a minor change has been made\nso controllers can be used.",
            "title": "Routing"
        },
        {
            "location": "/http/routing/#basic-routing",
            "text": "app.route('/', uses=(MyController, 'get_index'))  This will route the request to  get_index  in  MyController :  from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    \"\"\"\n    My Controller\n    \"\"\"\n\n    def initialize(self, **params):\n        \"\"\"\n        Initialize the controller\n        :param params:      The parameters in the url\n        :type  params:      dict\n        \"\"\"\n        super(MyController, self).initialize()\n\n    def get_index(self):\n        \"\"\"\n        Get the index-page\n        \"\"\"\n        return 'Hello World!'  As you can see there is a method called  initialize . This method is\nresponsible for initializing the controller.  Constructing and initializing the controller is done in this order:   Construct the controller  ( __init__ )  Initialize the controller  ( initialize )  Call the method and return the response  ( get_index )",
            "title": "Basic routing"
        },
        {
            "location": "/http/routing/#dynamic-routing",
            "text": "Adding variable parts to a url is done by marking them with special sections:  app.route('/user/<username>', uses=(MyController, 'get_user'))\napp.route('/post/<int:post_id>', uses=(MyController, 'get_post')) # Using converters  Other possible converters:   string : accepts any text without a slash (the default)  int : accepts integers  float : like int but for floating point values  path : like the default but also accepts slashes  any : matches one of the items provided  uuid : accepts UUID strings   These parameters are catched in the controller as followed:  def get_user(self, username = None):\n        return 'User: %s' % username\n\ndef get_post(self, post_id = None):\n        return 'Post with id: %d' % post_id  As seen previously, the parameters are also passed to the  initialize -method.",
            "title": "Dynamic routing"
        },
        {
            "location": "/http/routing/#http-methods",
            "text": "HTTP knows different methods which can be defined in the routes. By default the route will listen to  GET -requests.  app.route('/login', uses=(LoginController, 'get_login'), methods = ['GET'])\napp.route('/login', uses=(LoginController, 'post_login'), methods = ['POST'])  All supported methods:   GET  HEAD  POST  PUT  DELETE  OPTIONS",
            "title": "HTTP methods"
        },
        {
            "location": "/http/request/",
            "text": "Request\n\n\nRequest is available for usage when in request context.\n\n\nUsage\n\n\nThe current request can be accessed inside the controller and get used\nlike the flask request.\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        user_ip = self.request.remote_addr\n\n\n\n\n\n\nNote: for more on the request see the \nFlask documentation",
            "title": "Request"
        },
        {
            "location": "/http/request/#request",
            "text": "Request is available for usage when in request context.",
            "title": "Request"
        },
        {
            "location": "/http/request/#usage",
            "text": "The current request can be accessed inside the controller and get used\nlike the flask request.  from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        user_ip = self.request.remote_addr   Note: for more on the request see the  Flask documentation",
            "title": "Usage"
        },
        {
            "location": "/http/inputandvalidation/",
            "text": "Input and Validation\n\n\nFor an explanation on input and validation, you are on the right address.\n\n\nInput\n\n\nQuerystring-data, form-data and file-data are all combined in the Input-class.\nThe class takes the current request in its constructor and processed\nrequest.args, request.form and request.files. All data can be accessed like\nyou would access them separately.\n\n\nfrom edmunds.http.input import Input\nfrom edmunds.globals import request\n\ninput = Input(request)\nusername = input['username']\npassword = input['password']\ncity = input.get('city', 'unknown')\n\n\n\n\n\n\nNote: for more on the request-data see the \ndocs\n\n\n\n\nUsage in Controllers\n\n\nControllers are by default equipped with an instance of the input object.\nYou can use it to access the submitted data.\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        username = self.input['username']\n        password = self.input['password']\n        city = self.input.get('city', 'unknown')\n\n\n\n\nValidation\n\n\nEdmunds has a validator which extends from \nwtforms.Form\n. You can use it\nlike you would use WTForms. Validator has one extra attribute: \nvalidates\n\nwhich keeps the state of the last call to \nvalidates()\n.\n\n\n\n\nNote: for more on WTForms see the \ndocs\n\n\n\n\nUsage with Input\n\n\nInput has the Validator builtin. You can use it by passing your Validator-class\nto the \nvalidate\n-function.\n\n\nfrom edmunds.validation.validator import Validator\nfrom wtforms import StringField, PasswordField, validators\nfrom edmunds.http.controller import Controller\n\nclass LoginValidator(Validator):\n    email = StringField('Email Address', [validators.Length(min=6, max=35)])\n    password = PasswordField('Password', [validators.DataRequired()])\n\nclass MyController(Controller):\n    def login(self):\n        validator = self.input.validate(LoginValidator)\n        if validator.validates:\n            pass",
            "title": "Input and Validation"
        },
        {
            "location": "/http/inputandvalidation/#input-and-validation",
            "text": "For an explanation on input and validation, you are on the right address.",
            "title": "Input and Validation"
        },
        {
            "location": "/http/inputandvalidation/#input",
            "text": "Querystring-data, form-data and file-data are all combined in the Input-class.\nThe class takes the current request in its constructor and processed\nrequest.args, request.form and request.files. All data can be accessed like\nyou would access them separately.  from edmunds.http.input import Input\nfrom edmunds.globals import request\n\ninput = Input(request)\nusername = input['username']\npassword = input['password']\ncity = input.get('city', 'unknown')   Note: for more on the request-data see the  docs",
            "title": "Input"
        },
        {
            "location": "/http/inputandvalidation/#usage-in-controllers",
            "text": "Controllers are by default equipped with an instance of the input object.\nYou can use it to access the submitted data.  from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        username = self.input['username']\n        password = self.input['password']\n        city = self.input.get('city', 'unknown')",
            "title": "Usage in Controllers"
        },
        {
            "location": "/http/inputandvalidation/#validation",
            "text": "Edmunds has a validator which extends from  wtforms.Form . You can use it\nlike you would use WTForms. Validator has one extra attribute:  validates \nwhich keeps the state of the last call to  validates() .   Note: for more on WTForms see the  docs",
            "title": "Validation"
        },
        {
            "location": "/http/inputandvalidation/#usage-with-input",
            "text": "Input has the Validator builtin. You can use it by passing your Validator-class\nto the  validate -function.  from edmunds.validation.validator import Validator\nfrom wtforms import StringField, PasswordField, validators\nfrom edmunds.http.controller import Controller\n\nclass LoginValidator(Validator):\n    email = StringField('Email Address', [validators.Length(min=6, max=35)])\n    password = PasswordField('Password', [validators.DataRequired()])\n\nclass MyController(Controller):\n    def login(self):\n        validator = self.input.validate(LoginValidator)\n        if validator.validates:\n            pass",
            "title": "Usage with Input"
        },
        {
            "location": "/http/session/",
            "text": "Session\n\n\nTo activate session, enabled it by adding instances to your settings:\n\n\nfrom edmunds.session.drivers.sessioncookie import SessionCookie\n\nAPP = {\n    'session':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'sessioncookie',\n                'driver': SessionCookie\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances will all be used for session, so you can have multiple at once.\n\n\nThe available drivers are:\n\n\n\n\nSessionCookie\n: Sessions using cookies (see \ndocs\n)\n\n\n\n\nUsage\n\n\nController will have the first driver loaded for usage:\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        prev_username = self.session['username']\n        prev_username = self.session.pop('username', None)\n        del self.session['username']\n        self.session['username'] = self._input['username']\n\n\n\n\nUsage outside controller\n\n\nWhen in request-context, but not inside a controller, you can use the\napplication to get the driver-instance:\n\n\nsession = app.session()\nsession = app.session('sessioncookie')\n\nsession['key'] = 'value'\nprint session['key']\ndel session['key']",
            "title": "Session"
        },
        {
            "location": "/http/session/#session",
            "text": "To activate session, enabled it by adding instances to your settings:  from edmunds.session.drivers.sessioncookie import SessionCookie\n\nAPP = {\n    'session':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'sessioncookie',\n                'driver': SessionCookie\n            },\n        ],\n    },\n}  The instances will all be used for session, so you can have multiple at once.  The available drivers are:   SessionCookie : Sessions using cookies (see  docs )",
            "title": "Session"
        },
        {
            "location": "/http/session/#usage",
            "text": "Controller will have the first driver loaded for usage:  from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n        prev_username = self.session['username']\n        prev_username = self.session.pop('username', None)\n        del self.session['username']\n        self.session['username'] = self._input['username']",
            "title": "Usage"
        },
        {
            "location": "/http/session/#usage-outside-controller",
            "text": "When in request-context, but not inside a controller, you can use the\napplication to get the driver-instance:  session = app.session()\nsession = app.session('sessioncookie')\n\nsession['key'] = 'value'\nprint session['key']\ndel session['key']",
            "title": "Usage outside controller"
        },
        {
            "location": "/http/response/",
            "text": "Response\n\n\nResponse is available for usage when in request context.\n\n\nThe class implemented extends the Response-wrapper from Flask. So no\nchanges there. But a ResponseHelper has been implemented for your comfort.\nThe helper makes it easier to construct your responses.\n\n\n\n\nNote: for more on the response (not the helper) see the\n\nFlask documentation\n\n\n\n\nUsage\n\n\nThe current request can be accessed inside the controller and get used\nlike the flask request.\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Fix status for constructed responses\n        self.response.status(404)\n\n        # Assigns a value to a key\n        # Will be used when constructing json-, or render-responses\n        self.response.assign('name', 'Jon Snow')\n\n        # Assigns headers to constructed responses\n        self.response.header('XToken', 'mytoken')\n\n        # Assigns cookie to constructed responses\n        self.response.cookie('XToken', 'mytoken')\n\n        # Returns a rendered template (using assigned values)\n        result = self.response.render_template('mytemplate.html')\n\n        # Returns raw response with given content\n        return self.response.raw('My content')\n        # Returns json response with assigned values\n        return self.response.json()\n        # Returns response with rendered template (using assigned values)\n        return self.response.render('mytemplate.html')\n        # Returns response to redirect browser\n        return self.response.redirect('/newlocation')\n        # Returns file response\n        return self.response.file('filetodownload.txt')",
            "title": "Response"
        },
        {
            "location": "/http/response/#response",
            "text": "Response is available for usage when in request context.  The class implemented extends the Response-wrapper from Flask. So no\nchanges there. But a ResponseHelper has been implemented for your comfort.\nThe helper makes it easier to construct your responses.   Note: for more on the response (not the helper) see the Flask documentation",
            "title": "Response"
        },
        {
            "location": "/http/response/#usage",
            "text": "The current request can be accessed inside the controller and get used\nlike the flask request.  from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Fix status for constructed responses\n        self.response.status(404)\n\n        # Assigns a value to a key\n        # Will be used when constructing json-, or render-responses\n        self.response.assign('name', 'Jon Snow')\n\n        # Assigns headers to constructed responses\n        self.response.header('XToken', 'mytoken')\n\n        # Assigns cookie to constructed responses\n        self.response.cookie('XToken', 'mytoken')\n\n        # Returns a rendered template (using assigned values)\n        result = self.response.render_template('mytemplate.html')\n\n        # Returns raw response with given content\n        return self.response.raw('My content')\n        # Returns json response with assigned values\n        return self.response.json()\n        # Returns response with rendered template (using assigned values)\n        return self.response.render('mytemplate.html')\n        # Returns response to redirect browser\n        return self.response.redirect('/newlocation')\n        # Returns file response\n        return self.response.file('filetodownload.txt')",
            "title": "Usage"
        },
        {
            "location": "/http/visitor/",
            "text": "Visitor\n\n\nThe visitor class is used to get information regarding the client.\nBrowser-related-info, ip-based-location, localization,...\n\n\nTo make location and localization work, you will need to setup some\nconfiguration. See \nlocalization\n.\n\n\nUsage\n\n\nThe visitor object will be available in controllers when handling requests.\n\n\nfrom edmunds.http.controller import Controller\nfrom datetime import time, date\n\nclass MyController(Controller):\n    def login(self):\n\n        # Client info\n        client_os = self.visitor.client.os\n        client_browser = self.visitor.client.browser\n        client_device = self.visitor.client.device\n        client_is_mobile = self.visitor.client.is_mobile\n        client_is_bot = self.visitor.client.is_bot\n        # ...\n\n        # Ip-based-location\n        country_iso = self.visitor.location.country.iso_code\n        city_name = self.visitor.location.city.name\n        # ...\n\n        # Localization\n        time_str = self.visitor.localization.time.time(time(14, 3, 2))\n        date_str = self.visitor.localization.time.date(date(1992, 6, 7))\n        # ...\n        cost = self.visitor.localization.number.currency(4.56, 'EUR')\n        number = self.visitor.localization.number.number(3456.64)\n        # ...\n        is_rtl = self.visitor.localization.rtl\n        locale = self.visitor.localization.locale\n        # ...",
            "title": "Visitor"
        },
        {
            "location": "/http/visitor/#visitor",
            "text": "The visitor class is used to get information regarding the client.\nBrowser-related-info, ip-based-location, localization,...  To make location and localization work, you will need to setup some\nconfiguration. See  localization .",
            "title": "Visitor"
        },
        {
            "location": "/http/visitor/#usage",
            "text": "The visitor object will be available in controllers when handling requests.  from edmunds.http.controller import Controller\nfrom datetime import time, date\n\nclass MyController(Controller):\n    def login(self):\n\n        # Client info\n        client_os = self.visitor.client.os\n        client_browser = self.visitor.client.browser\n        client_device = self.visitor.client.device\n        client_is_mobile = self.visitor.client.is_mobile\n        client_is_bot = self.visitor.client.is_bot\n        # ...\n\n        # Ip-based-location\n        country_iso = self.visitor.location.country.iso_code\n        city_name = self.visitor.location.city.name\n        # ...\n\n        # Localization\n        time_str = self.visitor.localization.time.time(time(14, 3, 2))\n        date_str = self.visitor.localization.time.date(date(1992, 6, 7))\n        # ...\n        cost = self.visitor.localization.number.currency(4.56, 'EUR')\n        number = self.visitor.localization.number.number(3456.64)\n        # ...\n        is_rtl = self.visitor.localization.rtl\n        locale = self.visitor.localization.locale\n        # ...",
            "title": "Usage"
        },
        {
            "location": "/http/requestmiddleware/",
            "text": "Request Middleware\n\n\nRequest Middleware is the proper way of layering your request-handling.\nIt lets you add functionality before and after processing the request.\n\n\nDefine\n\n\nDefine your Request Middleware like so:\n\n\nfrom edmunds.http.requestmiddleware import RequestMiddleware\n\nclass MyRequestMiddleware(RequestMiddleware):\n    \"\"\"\n    My Request Middleware\n    \"\"\"\n\n    def before(self):\n        \"\"\"\n        Handle before the request\n        \"\"\"\n\n        return super(MyRequestMiddleware, self).before()\n\n    def after(self, response):\n        \"\"\"\n        Handle after the request\n        :param response:    The request response\n        :type  response:    flask.Response\n        :return:            The request response\n        :rtype:             flask.Response\n        \"\"\"\n\n        return super(MyRequestMiddleware, self).after(response)\n\n\n\n\n\n\nNote: The before- and after-function work respectively like the @app.before_request and @app.after_request of Flask.\n\n\n\n\nRegister\n\n\nRegister the Request Middleware in \nroutes.py\n as an option of the routes:\n\n\nfrom app.http.myrequestmiddleware import MyRequestMiddleware\nfrom app.http.myotherrequestmiddleware import MyOtherRequestMiddleware\nfrom app.http.mycontroller import MyController\n\napp.route('/', uses=(MyController, 'get_index')) \\\n    .middleware(MyRequestMiddleware)\n\napp.route('/route2', uses=(MyController, 'get_route2')) \\\n    .middleware(MyOtherRequestMiddleware, 'arg1', 'arg2', kwarg1='value')\n\n@app.route('/route3', middleware=[MyRequestMiddleware])\ndef old_skool_route():\n    return \"Hello World!\"\n\n@app.route('/route4', middleware=[(MyOtherRequestMiddleware, 'arg1', 'arg2')])\ndef second_old_skool_route():\n    return \"Hello World!\"\n\n\n\n\nThis way the before- and after-function of your Request Middleware is called.\n\n\n\n\nNote: The order in which the middleware is given, will also be the order in which they are called.",
            "title": "Request Middleware"
        },
        {
            "location": "/http/requestmiddleware/#request-middleware",
            "text": "Request Middleware is the proper way of layering your request-handling.\nIt lets you add functionality before and after processing the request.",
            "title": "Request Middleware"
        },
        {
            "location": "/http/requestmiddleware/#define",
            "text": "Define your Request Middleware like so:  from edmunds.http.requestmiddleware import RequestMiddleware\n\nclass MyRequestMiddleware(RequestMiddleware):\n    \"\"\"\n    My Request Middleware\n    \"\"\"\n\n    def before(self):\n        \"\"\"\n        Handle before the request\n        \"\"\"\n\n        return super(MyRequestMiddleware, self).before()\n\n    def after(self, response):\n        \"\"\"\n        Handle after the request\n        :param response:    The request response\n        :type  response:    flask.Response\n        :return:            The request response\n        :rtype:             flask.Response\n        \"\"\"\n\n        return super(MyRequestMiddleware, self).after(response)   Note: The before- and after-function work respectively like the @app.before_request and @app.after_request of Flask.",
            "title": "Define"
        },
        {
            "location": "/http/requestmiddleware/#register",
            "text": "Register the Request Middleware in  routes.py  as an option of the routes:  from app.http.myrequestmiddleware import MyRequestMiddleware\nfrom app.http.myotherrequestmiddleware import MyOtherRequestMiddleware\nfrom app.http.mycontroller import MyController\n\napp.route('/', uses=(MyController, 'get_index')) \\\n    .middleware(MyRequestMiddleware)\n\napp.route('/route2', uses=(MyController, 'get_route2')) \\\n    .middleware(MyOtherRequestMiddleware, 'arg1', 'arg2', kwarg1='value')\n\n@app.route('/route3', middleware=[MyRequestMiddleware])\ndef old_skool_route():\n    return \"Hello World!\"\n\n@app.route('/route4', middleware=[(MyOtherRequestMiddleware, 'arg1', 'arg2')])\ndef second_old_skool_route():\n    return \"Hello World!\"  This way the before- and after-function of your Request Middleware is called.   Note: The order in which the middleware is given, will also be the order in which they are called.",
            "title": "Register"
        },
        {
            "location": "/data/storage/",
            "text": "Storage\n\n\nFile-storage is a basic, necessary thing for every application.\nAnd in Edmunds it's highly customizable!\n\n\nSettings\n\n\nYou can set your storage preferences in the settings:\n\n\nfrom edmunds.storage.drivers.file import File\nfrom edmunds.storage.drivers.googlecloudstorage import GoogleCloudStorage\n\nAPP = {\n    'storage':\n    {\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': '/storage',  # Optional, default: '/storage'\n                # 'files_path': 'files',    # Optional, default: 'files'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n            {\n                'name': 'googlecloudstorage',\n                'driver': GoogleCloudStorage,\n                # 'bucket': 'mybucket',     # Optional, default: default bucket\n                # 'directory': '/storage',  # Optional, default: '/storage'\n                # 'files_path': 'files',    # Optional, default: 'files'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances can be used for storage, so you can have multiple at once.\nThe first one will be used by default.\n\n\nThe available drivers are:\n\n\n\n\nFile\n: Store files using the default file-system.\n\n\nGoogleCloudStorage\n: Store files using Google Cloud Storage.\n\n\n\n\nUsage\n\n\nYou can use the handler like so:\n\n\n# Fetch the default driver, or by name\ndriver = app.fs()\ndriver = app.fs('googlecloudstorage')\n\n# Path\n# This function is used when processing the input of the other functions below\nabsolute_path = app.fs().path('file.txt')  # /abs_path_to_storage/files/{prefix}file.txt\nabsolute_path = app.fs().path('/file.txt')  # /abs_path_to_storage/{prefix}file.txt\nabsolute_path = app.fs().path('directory/')  # /abs_path_to_storage/files/directory/\nabsolute_path = app.fs().path('/directory/')  # /abs_path_to_storage/directory/\nabsolute_path = app.fs().path(None)  # /abs_path_to_storage/files/\nabsolute_path = app.fs().path('/')  # /abs_path_to_storage/\n# Each function can set the prefix for that call:\nabsolute_path = app.fs().path('file.txt', prefix='')  # /abs_path_to_storage/files/file.txt\n\n# Write stream\nwrite_stream = app.fs().write_stream('file.txt')\n\n# Read stream\nwrite_stream = app.fs().read_stream('file.txt', prefix='')\n\n# Copy file\nsuccess = app.fs().copy('file.txt', 'file.txt.bak')\n\n# Remove file\nsuccess = app.fs().delete('file.txt', prefix='')\n\n# Exists?\ndoes_not_exist = app.fs().exists('file.txt')",
            "title": "Storage"
        },
        {
            "location": "/data/storage/#storage",
            "text": "File-storage is a basic, necessary thing for every application.\nAnd in Edmunds it's highly customizable!",
            "title": "Storage"
        },
        {
            "location": "/data/storage/#settings",
            "text": "You can set your storage preferences in the settings:  from edmunds.storage.drivers.file import File\nfrom edmunds.storage.drivers.googlecloudstorage import GoogleCloudStorage\n\nAPP = {\n    'storage':\n    {\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': '/storage',  # Optional, default: '/storage'\n                # 'files_path': 'files',    # Optional, default: 'files'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n            {\n                'name': 'googlecloudstorage',\n                'driver': GoogleCloudStorage,\n                # 'bucket': 'mybucket',     # Optional, default: default bucket\n                # 'directory': '/storage',  # Optional, default: '/storage'\n                # 'files_path': 'files',    # Optional, default: 'files'\n                # 'prefix': 'Myapp.',       # Optional, default: ''\n            },\n        ],\n    },\n}  The instances can be used for storage, so you can have multiple at once.\nThe first one will be used by default.  The available drivers are:   File : Store files using the default file-system.  GoogleCloudStorage : Store files using Google Cloud Storage.",
            "title": "Settings"
        },
        {
            "location": "/data/storage/#usage",
            "text": "You can use the handler like so:  # Fetch the default driver, or by name\ndriver = app.fs()\ndriver = app.fs('googlecloudstorage')\n\n# Path\n# This function is used when processing the input of the other functions below\nabsolute_path = app.fs().path('file.txt')  # /abs_path_to_storage/files/{prefix}file.txt\nabsolute_path = app.fs().path('/file.txt')  # /abs_path_to_storage/{prefix}file.txt\nabsolute_path = app.fs().path('directory/')  # /abs_path_to_storage/files/directory/\nabsolute_path = app.fs().path('/directory/')  # /abs_path_to_storage/directory/\nabsolute_path = app.fs().path(None)  # /abs_path_to_storage/files/\nabsolute_path = app.fs().path('/')  # /abs_path_to_storage/\n# Each function can set the prefix for that call:\nabsolute_path = app.fs().path('file.txt', prefix='')  # /abs_path_to_storage/files/file.txt\n\n# Write stream\nwrite_stream = app.fs().write_stream('file.txt')\n\n# Read stream\nwrite_stream = app.fs().read_stream('file.txt', prefix='')\n\n# Copy file\nsuccess = app.fs().copy('file.txt', 'file.txt.bak')\n\n# Remove file\nsuccess = app.fs().delete('file.txt', prefix='')\n\n# Exists?\ndoes_not_exist = app.fs().exists('file.txt')",
            "title": "Usage"
        },
        {
            "location": "/data/database/",
            "text": "Database\n\n\nDatabase usage is built in in Edmunds and uses\n\nFlask-SQLAlchemy\n.\n\n\nSettings\n\n\nYou can set your database preferences in the settings:\n\n\nfrom edmunds.database.drivers.mysql import MySql\nfrom edmunds.database.drivers.postgresql import PostgreSql\nfrom edmunds.database.drivers.sqlite import Sqlite\n\nAPP = {\n    'database':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'mysql',\n                'driver': MySql,\n                'user': 'root',\n                'pass': 'root',\n                'host': 'localhost',\n                'database': 'edmunds',\n                # 'port': '3306',   # Optional, default: '3306'\n            },\n            {\n                'name': 'postgresql',\n                'driver': PostgreSql,\n                'user': 'root',\n                'pass': 'root',\n                'host': 'localhost',\n                'database': 'edmunds',\n                # 'port': '5432',   # Optional, default: '5432'\n            },\n            {\n                'name': 'sqlite',\n                'driver': Sqlite,\n                'file': 'sqlite.db',\n                # 'storage': 'storage_name',    # Optional, default storage used as default\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances can be used for database, so you can have multiple at once.\nThe first one will be used by default.\n\n\nThe available drivers are:\n\n\n\n\nMySql\n: For MySQL databases.\n\n\nPostgreSql\n: For PostgreSQL databases.\n\n\nSQLite\n: For SQLite databases.\n\n\n\n\n\n\nMore in detail: the default instance will be used as \nSQLALCHEMY_DATABASE_URI\n\nin SQLAlchemy. Other instances (not including the default instance) will\nbe added to \nSQLALCHEMY_BINDS\n.\n\n\n\n\nUsage\n\n\nWhen fetching an instance, you will receive a database-engine\n(sqlalchemy.engine.base.Engine) for the specified database instance.\nYou can request one like so:\n\n\n# Fetch the default driver, or by name\nengine = app.database_engine()\nengine = app.database_engine(name='mysql')\n\n\n\n\nFetching a session can be done with \ndatabase_session\n. You will receive a\nSession-class (sqlalchemy.orm.scoping.scoped_session) for session-usage.\nSessions will be teared down when the request ends or when the app shuts\ndown (using \napp.teardown_appcontext\n).\n\n\nsession = app.database_session()\nsession = app.database_session(name='mysql')\n\nsession.add(user)\nsession.commit()\n\n\n\n\nFurther usage of the database-engine and -session are described in the\nSQLAlchemy documentation:\n\n\n\n\nFlask-SQLAlchemy\n\n\nSQLAlchemy - Working with Engines and Connections\n\n\nSQLAlchemy - Session Basics",
            "title": "Database"
        },
        {
            "location": "/data/database/#database",
            "text": "Database usage is built in in Edmunds and uses Flask-SQLAlchemy .",
            "title": "Database"
        },
        {
            "location": "/data/database/#settings",
            "text": "You can set your database preferences in the settings:  from edmunds.database.drivers.mysql import MySql\nfrom edmunds.database.drivers.postgresql import PostgreSql\nfrom edmunds.database.drivers.sqlite import Sqlite\n\nAPP = {\n    'database':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'mysql',\n                'driver': MySql,\n                'user': 'root',\n                'pass': 'root',\n                'host': 'localhost',\n                'database': 'edmunds',\n                # 'port': '3306',   # Optional, default: '3306'\n            },\n            {\n                'name': 'postgresql',\n                'driver': PostgreSql,\n                'user': 'root',\n                'pass': 'root',\n                'host': 'localhost',\n                'database': 'edmunds',\n                # 'port': '5432',   # Optional, default: '5432'\n            },\n            {\n                'name': 'sqlite',\n                'driver': Sqlite,\n                'file': 'sqlite.db',\n                # 'storage': 'storage_name',    # Optional, default storage used as default\n            },\n        ],\n    },\n}  The instances can be used for database, so you can have multiple at once.\nThe first one will be used by default.  The available drivers are:   MySql : For MySQL databases.  PostgreSql : For PostgreSQL databases.  SQLite : For SQLite databases.    More in detail: the default instance will be used as  SQLALCHEMY_DATABASE_URI \nin SQLAlchemy. Other instances (not including the default instance) will\nbe added to  SQLALCHEMY_BINDS .",
            "title": "Settings"
        },
        {
            "location": "/data/database/#usage",
            "text": "When fetching an instance, you will receive a database-engine\n(sqlalchemy.engine.base.Engine) for the specified database instance.\nYou can request one like so:  # Fetch the default driver, or by name\nengine = app.database_engine()\nengine = app.database_engine(name='mysql')  Fetching a session can be done with  database_session . You will receive a\nSession-class (sqlalchemy.orm.scoping.scoped_session) for session-usage.\nSessions will be teared down when the request ends or when the app shuts\ndown (using  app.teardown_appcontext ).  session = app.database_session()\nsession = app.database_session(name='mysql')\n\nsession.add(user)\nsession.commit()  Further usage of the database-engine and -session are described in the\nSQLAlchemy documentation:   Flask-SQLAlchemy  SQLAlchemy - Working with Engines and Connections  SQLAlchemy - Session Basics",
            "title": "Usage"
        },
        {
            "location": "/data/orm/",
            "text": "ORM\n\n\nObject-Relational Mapping is implemented using\n\nFlask-SQLAlchemy\n.\n\n\nDefining and mapping models\n\n\nFirst off you need to define your models as described by the\n\nSQL-Alchemy documentation\n:\n\n\n# app/database/models/users.py\nfrom edmunds.database.db import db\nclass User(db.Model):\n    # __bind_key__ = 'users_database'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50))\n\n# app/database/models/tags.py\nfrom edmunds.database.db import db\nclass Tag(db.Model):\n    # __bind_key__ = 'users_database'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), unique=True)\n\n# app/database/models/usertags.py\nfrom edmunds.database.db import db\nUserTagsTable = db.Table(\n    'user_tags',\n    db.Column('user_id', db.Integer, db.ForeignKey('tags.id'), primary_key=True),\n    db.Column('tag_id', db.Integer, db.ForeignKey('users.id'), primary_key=True),\n    # info={'bind_key': 'users_database'}\n)\n\n\n\n\nInsert, Update, Delete\n\n\nThe actions work the same way as Flask-SQLAlchemy does:\n\n\nsession = app.database_session()\npeter = User(name='peter')\n\n# Inserting\nsession.add(peter)\nsession.commit()\nprint peter.id\n\n# Updating\npeter.name = 'peter verkest'\nsession.commit()\n\n# Deleting\nsession.delete(peter)\nsession.commit()\n\n\n\n\nFurther documentation:\n\n\n\n\nFlask-SQLAlchemy Select, Insert, Delete\n\n\nSQLAlchemy Adding and Updating Objects\n\n\n\n\n\n\nNote: These actions are handy, but not efficient when running in bulk.\nTake a look at this \nStackOverflow-question\n.\n\n\n\n\nQuerying\n\n\nQuerying works as defined in Flask-SQLAlchemy.\n\n\nusers = User.query.all()\npeter = User.query.filter_by(name='peter').first()\n\n\n\n\nFurther documentation on querying:\n\n\n\n\nFlask-SQLAlchemy Querying Records\n\n\nSQLAlchemy Querying",
            "title": "ORM"
        },
        {
            "location": "/data/orm/#orm",
            "text": "Object-Relational Mapping is implemented using Flask-SQLAlchemy .",
            "title": "ORM"
        },
        {
            "location": "/data/orm/#defining-and-mapping-models",
            "text": "First off you need to define your models as described by the SQL-Alchemy documentation :  # app/database/models/users.py\nfrom edmunds.database.db import db\nclass User(db.Model):\n    # __bind_key__ = 'users_database'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50))\n\n# app/database/models/tags.py\nfrom edmunds.database.db import db\nclass Tag(db.Model):\n    # __bind_key__ = 'users_database'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), unique=True)\n\n# app/database/models/usertags.py\nfrom edmunds.database.db import db\nUserTagsTable = db.Table(\n    'user_tags',\n    db.Column('user_id', db.Integer, db.ForeignKey('tags.id'), primary_key=True),\n    db.Column('tag_id', db.Integer, db.ForeignKey('users.id'), primary_key=True),\n    # info={'bind_key': 'users_database'}\n)",
            "title": "Defining and mapping models"
        },
        {
            "location": "/data/orm/#insert-update-delete",
            "text": "The actions work the same way as Flask-SQLAlchemy does:  session = app.database_session()\npeter = User(name='peter')\n\n# Inserting\nsession.add(peter)\nsession.commit()\nprint peter.id\n\n# Updating\npeter.name = 'peter verkest'\nsession.commit()\n\n# Deleting\nsession.delete(peter)\nsession.commit()  Further documentation:   Flask-SQLAlchemy Select, Insert, Delete  SQLAlchemy Adding and Updating Objects    Note: These actions are handy, but not efficient when running in bulk.\nTake a look at this  StackOverflow-question .",
            "title": "Insert, Update, Delete"
        },
        {
            "location": "/data/orm/#querying",
            "text": "Querying works as defined in Flask-SQLAlchemy.  users = User.query.all()\npeter = User.query.filter_by(name='peter').first()  Further documentation on querying:   Flask-SQLAlchemy Querying Records  SQLAlchemy Querying",
            "title": "Querying"
        },
        {
            "location": "/data/migrations/",
            "text": "Migrations\n\n\nDatabase migrations are built in in Edmunds using \nFlask-Migrate\n.\n\n\nUsage\n\n\nEdmunds has already integrated the db-command in the application's manager.\nYou can use it as described in the Flask-Migrate-documentation:\n\n\npython manage.py db --help\n\n# Init for your project:\npython manage.py db init --multidb\n# Migrate the changes:\npython manage.py db migrate -m \"Added some tables\"\n# Upgrade the databases:\npython manage.py db upgrade\n\n\n\n\nUsage of Flask-Migrate documentation:\n\n\n\n\nFlask-Migrate\n\n\n\n\nModels & Tables\n\n\nModels and tables of SQLAlchemy are used by Flask-Migrate to describe your\ndatabase structure. Add your models and tables to \napp.database.models\n so\nthey are picked up by the migration-service:\n\n\n# app/database/models/users.py\nfrom edmunds.database.db import db\nclass User(db.Model):\n    # __bind_key__ = 'users_database'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50))\n\n# app/database/models/tags.py\nfrom edmunds.database.db import db\nclass Tag(db.Model):\n    # __bind_key__ = 'users_database'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), unique=True)\n\n# app/database/models/usertags.py\nfrom edmunds.database.db import db\nUserTagsTable = db.Table(\n    'user_tags',\n    db.Column('user_id', db.Integer, db.ForeignKey('tags.id'), primary_key=True),\n    db.Column('tag_id', db.Integer, db.ForeignKey('users.id'), primary_key=True),\n    # info={'bind_key': 'users_database'}\n)\n\n\n\n\nFurther documentation on how to declare your models and tables can be\nfound here:\n\n\n\n\nSQLAlchemy Schema Definition Language\n\n\nMultiple Databases (binds)\n\n\n\n\n\n\nNote: If you want to customize the package where the migrate-service looks\nfor models and tables, you can override it in your config:\n\npython\nAPP = {\n    'database': {\n        # ...\n        'models': {\n            'my/location/to/the/models',\n            'second/location/to/other/tables',\n        },\n    },\n}\n\nThe described paths are relative to the root-folder of your application.",
            "title": "Migrations"
        },
        {
            "location": "/data/migrations/#migrations",
            "text": "Database migrations are built in in Edmunds using  Flask-Migrate .",
            "title": "Migrations"
        },
        {
            "location": "/data/migrations/#usage",
            "text": "Edmunds has already integrated the db-command in the application's manager.\nYou can use it as described in the Flask-Migrate-documentation:  python manage.py db --help\n\n# Init for your project:\npython manage.py db init --multidb\n# Migrate the changes:\npython manage.py db migrate -m \"Added some tables\"\n# Upgrade the databases:\npython manage.py db upgrade  Usage of Flask-Migrate documentation:   Flask-Migrate",
            "title": "Usage"
        },
        {
            "location": "/data/migrations/#models-tables",
            "text": "Models and tables of SQLAlchemy are used by Flask-Migrate to describe your\ndatabase structure. Add your models and tables to  app.database.models  so\nthey are picked up by the migration-service:  # app/database/models/users.py\nfrom edmunds.database.db import db\nclass User(db.Model):\n    # __bind_key__ = 'users_database'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50))\n\n# app/database/models/tags.py\nfrom edmunds.database.db import db\nclass Tag(db.Model):\n    # __bind_key__ = 'users_database'\n    id = db.Column(db.Integer, primary_key=True)\n    name = db.Column(db.String(50), unique=True)\n\n# app/database/models/usertags.py\nfrom edmunds.database.db import db\nUserTagsTable = db.Table(\n    'user_tags',\n    db.Column('user_id', db.Integer, db.ForeignKey('tags.id'), primary_key=True),\n    db.Column('tag_id', db.Integer, db.ForeignKey('users.id'), primary_key=True),\n    # info={'bind_key': 'users_database'}\n)  Further documentation on how to declare your models and tables can be\nfound here:   SQLAlchemy Schema Definition Language  Multiple Databases (binds)    Note: If you want to customize the package where the migrate-service looks\nfor models and tables, you can override it in your config: python\nAPP = {\n    'database': {\n        # ...\n        'models': {\n            'my/location/to/the/models',\n            'second/location/to/other/tables',\n        },\n    },\n} \nThe described paths are relative to the root-folder of your application.",
            "title": "Models &amp; Tables"
        },
        {
            "location": "/data/caching/",
            "text": "Caching\n\n\nCache usage is built in in Edmunds and uses\n\nWerkzeug Cache\n.\n\n\nSettings\n\n\nYou can set your caching preferences in the settings:\n\n\nfrom edmunds.cache.drivers.file import File\nfrom edmunds.cache.drivers.memcached import Memcached\nfrom edmunds.cache.drivers.redis import Redis\n\nAPP = {\n    'cache':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': '',          # Optional, default: '' (= logs/)\n                # 'threshold': 500,         # Optional, default: 500\n                # 'default_timeout': 300,   # Optional, default: 300\n                # 'mode': 0o600,            # Optional, default: 0o600\n            },\n            {\n                'name': 'memcached',\n                'driver': Memcached,\n                # 'servers': ['127.0.0.1:11211'],   # Optional, default: ['127.0.0.1:11211']\n                # 'default_timeout': 300,           # Optional, default: 300\n                # 'key_prefix': None,               # Optional, default: None\n            },\n            {\n                'name': 'redis',\n                'driver': Redis,\n                # 'host': 'localhost',      # Optional, default: 'localhost'\n                # 'port': 6379,             # Optional, default: 6379\n                # 'password': None,         # Optional, default: None\n                # 'db': 0,                  # Optional, default: 0\n                # 'default_timeout': 300,   # Optional, default: 300\n                # 'key_prefix': None,       # Optional, default: None\n            },\n        ],\n    },\n}\n\n\n\n\nThe instances can be used for database, so you can have multiple at once.\nThe first one will be used by default.\n\n\nThe available drivers are:\n\n\n\n\nFile\n: For caching using files.\n\n\nMemcached\n: For Memcached caching.\n\n\nRedis\n: For Redis caching.\n\n\n\n\nThis configuration is based off the original arguments of the Werkzeug cache\ndrivers. So more information regarding configuration can be found in the\nWerkzeug documentation:\n\n\n\n\nWerkzeug Cache\n\n\n\n\nUsage\n\n\nWhen fetching an instance, you will receive a cache-driver\n(\nwerkzeug.contrib.cache.BaseCache\n) for the specified cache instance.\nYou can request one like so:\n\n\n# Fetch the default driver, or by name\ndriver = app.cache()\ndriver = app.cache(name='memcached')\n\n\n\n\nFurther usage of the cache-driver is described in the Werkzeug documentation:\n\n\n\n\nWerkzeug Cache",
            "title": "Caching"
        },
        {
            "location": "/data/caching/#caching",
            "text": "Cache usage is built in in Edmunds and uses Werkzeug Cache .",
            "title": "Caching"
        },
        {
            "location": "/data/caching/#settings",
            "text": "You can set your caching preferences in the settings:  from edmunds.cache.drivers.file import File\nfrom edmunds.cache.drivers.memcached import Memcached\nfrom edmunds.cache.drivers.redis import Redis\n\nAPP = {\n    'cache':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'file',\n                'driver': File,\n                # 'directory': '',          # Optional, default: '' (= logs/)\n                # 'threshold': 500,         # Optional, default: 500\n                # 'default_timeout': 300,   # Optional, default: 300\n                # 'mode': 0o600,            # Optional, default: 0o600\n            },\n            {\n                'name': 'memcached',\n                'driver': Memcached,\n                # 'servers': ['127.0.0.1:11211'],   # Optional, default: ['127.0.0.1:11211']\n                # 'default_timeout': 300,           # Optional, default: 300\n                # 'key_prefix': None,               # Optional, default: None\n            },\n            {\n                'name': 'redis',\n                'driver': Redis,\n                # 'host': 'localhost',      # Optional, default: 'localhost'\n                # 'port': 6379,             # Optional, default: 6379\n                # 'password': None,         # Optional, default: None\n                # 'db': 0,                  # Optional, default: 0\n                # 'default_timeout': 300,   # Optional, default: 300\n                # 'key_prefix': None,       # Optional, default: None\n            },\n        ],\n    },\n}  The instances can be used for database, so you can have multiple at once.\nThe first one will be used by default.  The available drivers are:   File : For caching using files.  Memcached : For Memcached caching.  Redis : For Redis caching.   This configuration is based off the original arguments of the Werkzeug cache\ndrivers. So more information regarding configuration can be found in the\nWerkzeug documentation:   Werkzeug Cache",
            "title": "Settings"
        },
        {
            "location": "/data/caching/#usage",
            "text": "When fetching an instance, you will receive a cache-driver\n( werkzeug.contrib.cache.BaseCache ) for the specified cache instance.\nYou can request one like so:  # Fetch the default driver, or by name\ndriver = app.cache()\ndriver = app.cache(name='memcached')  Further usage of the cache-driver is described in the Werkzeug documentation:   Werkzeug Cache",
            "title": "Usage"
        },
        {
            "location": "/localization/introduction/",
            "text": "Localization\n\n\nLocalization is used to tailor an experience for the user that is totally\ncustomized to his/her language, unit-system, currency,...\n\n\nAccuracy in localization is achieved using different sources and factors:\n\n\n\n\nLocale is determined based on (first = highest priority):\n\n\nGiven locale (fixed locale set on client side. given as argument.)\n\n\nBrowser accept languages\n\n\nUser agent\n\n\nFallback locale set in config\n\n\nLocation is determined on the client ip address using the given drivers.\n\n\nTime-zone is determined based on (first = highest priority):\n\n\nLocation\n\n\nFallback time-zone set in config\n\n\n\n\nThe locale will determine how values are formatted and which translations\nare shown to the user. The locales are processed for usage and will comply\nto the following rules:\n\n\n\n\nLocales specifying a region will also be processed without region\n(nl_NL => nl_NL, nl)\n\n\nOnly supported locales will be used.\n\n\n\n\nConfiguration\n\n\nThis is an example configuration. See related localization-documentation for\nmore information.\n\n\nfrom edmunds.localization.location.drivers.maxmindcitydatabase import MaxMindCityDatabase\nfrom edmunds.localization.translations.drivers.configtranslator import ConfigTranslator\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'location': {\n            'enabled': True,\n            'instances': [\n                {\n                    'name': 'maxmindcitydb',\n                    'driver': MaxMindCityDatabase,\n                    'database': 'maxmind_city_db.mmdb'\n                },\n            ],\n        },\n\n        'translations': {\n            'enabled': True,\n            'instances': [\n                   {\n                    'name': 'configtranslator',\n                    'driver': ConfigTranslator,\n                },\n            ],\n        },\n    },\n}\n\n\n\n\nUsage\n\n\nThe general localization will be shown here. Other usages will be shown in the\nrelated localization-documentation.\n\n\n\n\nNote: Localization will be more accurate when the location of the user\nis available.\n\n\n\n\nfrom edmunds.http.controller import Controller\nfrom datetime import time, date\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n\n        time_str = self.visitor.localizator.time.time(time(14, 3, 2))\n        date_str = self.visitor.localizator.time.date(date(1992, 6, 7))\n        # ...\n        cost = self.visitor.localizator.number.currency(4.56, 'EUR')\n        number = self.visitor.localizator.number.number(3456.64)\n        # ...\n        is_rtl = self.visitor.localizator.rtl\n        locale = self.visitor.localizator.locale\n        # ...\n\n\n        # Usage through the app/manager\n\n        localization_manager = self.app.localization()\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self.request.remote_addr)\n        localizator_model = localization_manager.localizator(location)\n\n        time_str = localizator_model.time.time(time(14, 3, 2))\n        date_str = localizator_model.time.date(date(1992, 6, 7))\n        # ...\n        cost = localizator_model.number.currency(4.56, 'EUR')\n        number = localizator_model.number.number(3456.64)\n        # ...\n        is_rtl = localizator_model.rtl\n        locale = localizator_model.locale\n        # ...",
            "title": "Introduction"
        },
        {
            "location": "/localization/introduction/#localization",
            "text": "Localization is used to tailor an experience for the user that is totally\ncustomized to his/her language, unit-system, currency,...  Accuracy in localization is achieved using different sources and factors:   Locale is determined based on (first = highest priority):  Given locale (fixed locale set on client side. given as argument.)  Browser accept languages  User agent  Fallback locale set in config  Location is determined on the client ip address using the given drivers.  Time-zone is determined based on (first = highest priority):  Location  Fallback time-zone set in config   The locale will determine how values are formatted and which translations\nare shown to the user. The locales are processed for usage and will comply\nto the following rules:   Locales specifying a region will also be processed without region\n(nl_NL => nl_NL, nl)  Only supported locales will be used.",
            "title": "Localization"
        },
        {
            "location": "/localization/introduction/#configuration",
            "text": "This is an example configuration. See related localization-documentation for\nmore information.  from edmunds.localization.location.drivers.maxmindcitydatabase import MaxMindCityDatabase\nfrom edmunds.localization.translations.drivers.configtranslator import ConfigTranslator\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'location': {\n            'enabled': True,\n            'instances': [\n                {\n                    'name': 'maxmindcitydb',\n                    'driver': MaxMindCityDatabase,\n                    'database': 'maxmind_city_db.mmdb'\n                },\n            ],\n        },\n\n        'translations': {\n            'enabled': True,\n            'instances': [\n                   {\n                    'name': 'configtranslator',\n                    'driver': ConfigTranslator,\n                },\n            ],\n        },\n    },\n}",
            "title": "Configuration"
        },
        {
            "location": "/localization/introduction/#usage",
            "text": "The general localization will be shown here. Other usages will be shown in the\nrelated localization-documentation.   Note: Localization will be more accurate when the location of the user\nis available.   from edmunds.http.controller import Controller\nfrom datetime import time, date\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n\n        time_str = self.visitor.localizator.time.time(time(14, 3, 2))\n        date_str = self.visitor.localizator.time.date(date(1992, 6, 7))\n        # ...\n        cost = self.visitor.localizator.number.currency(4.56, 'EUR')\n        number = self.visitor.localizator.number.number(3456.64)\n        # ...\n        is_rtl = self.visitor.localizator.rtl\n        locale = self.visitor.localizator.locale\n        # ...\n\n\n        # Usage through the app/manager\n\n        localization_manager = self.app.localization()\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self.request.remote_addr)\n        localizator_model = localization_manager.localizator(location)\n\n        time_str = localizator_model.time.time(time(14, 3, 2))\n        date_str = localizator_model.time.date(date(1992, 6, 7))\n        # ...\n        cost = localizator_model.number.currency(4.56, 'EUR')\n        number = localizator_model.number.number(3456.64)\n        # ...\n        is_rtl = localizator_model.rtl\n        locale = localizator_model.locale\n        # ...",
            "title": "Usage"
        },
        {
            "location": "/localization/location/",
            "text": "Location\n\n\nThis documentation describes how the location of a user can be fetched by ip.\n\n\nConfiguration\n\n\nfrom edmunds.localization.location.drivers.maxmindcitydatabase import MaxMindCityDatabase\nfrom edmunds.localization.location.drivers.maxmindenterprisedatabase import MaxMindEnterpriseDatabase\nfrom edmunds.localization.location.drivers.maxmindwebservice import MaxMindWebService\nfrom edmunds.localization.location.drivers.googleappengine import GoogleAppEngine\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'location': {\n            'enabled': True,\n            'instances': [\n                {\n                    'name': 'gae',\n                    'driver': GoogleAppEngine,\n                },\n                {\n                    'name': 'maxmindcitydb',\n                    'driver': MaxMindCityDatabase,\n                    'database': 'maxmind_city_db.mmdb'\n                },\n                {\n                    'name': 'maxmindenterprisedb',\n                    'driver': MaxMindEnterpriseDatabase,\n                    'database': 'maxmind_enterprise_db.mmdb'\n                },\n                {\n                    'name': 'maxmindweb',\n                    'driver': MaxMindWebService,\n                    'user_id': '1',\n                    'license_key': 'license_key'\n                },\n            ],\n        },\n    },\n}\n\n\n\n\nThe available drivers are:\n\n\n\n\nMaxMindCityDatabase\n: Using MaxMind City Database\n\n\nMaxMindEnterpriseDatabase\n: Using MaxMind Enterprise Database\n\n\nMaxMindWebService\n: Using MaxMind Web Service\n\n\nGoogleAppEngine\n: Based on specific Google App Engine headers\n\n\n\n\nUsage\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n        # Note: Visitor will use the first location driver!\n\n        country_iso = self.visitor.location.country.iso_code\n        city_name = self.visitor.location.city.name\n        # ...\n\n\n        # Usage through the app/manager\n\n        localization_manager = self.app.localization()\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self.request.remote_addr)\n\n        country_iso = location.country.iso_code\n        city_name = location.city.name\n        # ...",
            "title": "Location"
        },
        {
            "location": "/localization/location/#location",
            "text": "This documentation describes how the location of a user can be fetched by ip.",
            "title": "Location"
        },
        {
            "location": "/localization/location/#configuration",
            "text": "from edmunds.localization.location.drivers.maxmindcitydatabase import MaxMindCityDatabase\nfrom edmunds.localization.location.drivers.maxmindenterprisedatabase import MaxMindEnterpriseDatabase\nfrom edmunds.localization.location.drivers.maxmindwebservice import MaxMindWebService\nfrom edmunds.localization.location.drivers.googleappengine import GoogleAppEngine\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'location': {\n            'enabled': True,\n            'instances': [\n                {\n                    'name': 'gae',\n                    'driver': GoogleAppEngine,\n                },\n                {\n                    'name': 'maxmindcitydb',\n                    'driver': MaxMindCityDatabase,\n                    'database': 'maxmind_city_db.mmdb'\n                },\n                {\n                    'name': 'maxmindenterprisedb',\n                    'driver': MaxMindEnterpriseDatabase,\n                    'database': 'maxmind_enterprise_db.mmdb'\n                },\n                {\n                    'name': 'maxmindweb',\n                    'driver': MaxMindWebService,\n                    'user_id': '1',\n                    'license_key': 'license_key'\n                },\n            ],\n        },\n    },\n}  The available drivers are:   MaxMindCityDatabase : Using MaxMind City Database  MaxMindEnterpriseDatabase : Using MaxMind Enterprise Database  MaxMindWebService : Using MaxMind Web Service  GoogleAppEngine : Based on specific Google App Engine headers",
            "title": "Configuration"
        },
        {
            "location": "/localization/location/#usage",
            "text": "from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n        # Note: Visitor will use the first location driver!\n\n        country_iso = self.visitor.location.country.iso_code\n        city_name = self.visitor.location.city.name\n        # ...\n\n\n        # Usage through the app/manager\n\n        localization_manager = self.app.localization()\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self.request.remote_addr)\n\n        country_iso = location.country.iso_code\n        city_name = location.city.name\n        # ...",
            "title": "Usage"
        },
        {
            "location": "/localization/formatting/",
            "text": "Formatting\n\n\nFormatting of values is mandatory when localizing your application. One thousand\nthree hundred forty five point twenty two is not written the same everywhere:\n1,345.22 ; 1.345,22 ; 1345,22 ; ... Also time should be formatted to the users\ntime-zone.\n\n\nConfiguration\n\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n    },\n}\n\n\n\n\nUsage\n\n\nfrom edmunds.http.controller import Controller\nfrom datetime import time, date, datetime\nfrom edmunds.localization.localization.models.time import Time\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n\n        formatted_integer = self.visitor.localizator.number.number(1345)\n        formatted_decimal = self.visitor.localizator.number.number(1345.22)\n        formatted_currency = self.visitor.localizator.number.currency(1345.22, 'EUR')\n        formatted_percentage = self.visitor.localizator.number.percent(0.35)\n        formatted_scientific = self.visitor.localizator.number.scientific(232339)\n        formatted_rtl = self.visitor.localizator.rtl\n        # ...\n\n\n        # Usage through the app/manager\n\n        # Localization manager\n        localization_manager = self.app.localization()\n        # Location\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self.request.remote_addr)\n        # Translator\n        translator = localization_manager.translator()\n        # Localizator\n        localizator = localization_manager.localizator(location, translator)\n\n        formatted_time = localizator.time.time(time(22, 26, 12))\n        formatted_time = localizator.time.time(time(22, 26, 12), format=Time.LONG)\n        formatted_date = localizator.time.date(date(2017, 9, 18))\n        formatted_date = localizator.time.date(date(2017, 9, 18), format=Time.SHORT)\n        formatted_date = localizator.time.date(date(2017, 9, 18), format=Time.FULL)\n        formatted_datetime = localizator.time.datetime(datetime(2017, 9, 18, 22, 26, 12))\n        # ...",
            "title": "Formatting"
        },
        {
            "location": "/localization/formatting/#formatting",
            "text": "Formatting of values is mandatory when localizing your application. One thousand\nthree hundred forty five point twenty two is not written the same everywhere:\n1,345.22 ; 1.345,22 ; 1345,22 ; ... Also time should be formatted to the users\ntime-zone.",
            "title": "Formatting"
        },
        {
            "location": "/localization/formatting/#configuration",
            "text": "APP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n    },\n}",
            "title": "Configuration"
        },
        {
            "location": "/localization/formatting/#usage",
            "text": "from edmunds.http.controller import Controller\nfrom datetime import time, date, datetime\nfrom edmunds.localization.localization.models.time import Time\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n\n        formatted_integer = self.visitor.localizator.number.number(1345)\n        formatted_decimal = self.visitor.localizator.number.number(1345.22)\n        formatted_currency = self.visitor.localizator.number.currency(1345.22, 'EUR')\n        formatted_percentage = self.visitor.localizator.number.percent(0.35)\n        formatted_scientific = self.visitor.localizator.number.scientific(232339)\n        formatted_rtl = self.visitor.localizator.rtl\n        # ...\n\n\n        # Usage through the app/manager\n\n        # Localization manager\n        localization_manager = self.app.localization()\n        # Location\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self.request.remote_addr)\n        # Translator\n        translator = localization_manager.translator()\n        # Localizator\n        localizator = localization_manager.localizator(location, translator)\n\n        formatted_time = localizator.time.time(time(22, 26, 12))\n        formatted_time = localizator.time.time(time(22, 26, 12), format=Time.LONG)\n        formatted_date = localizator.time.date(date(2017, 9, 18))\n        formatted_date = localizator.time.date(date(2017, 9, 18), format=Time.SHORT)\n        formatted_date = localizator.time.date(date(2017, 9, 18), format=Time.FULL)\n        formatted_datetime = localizator.time.datetime(datetime(2017, 9, 18, 22, 26, 12))\n        # ...",
            "title": "Usage"
        },
        {
            "location": "/localization/translations/",
            "text": "Translations\n\n\nTranslations and user experience go hand in hand like cookies and milk.\nThat's why Edmunds helps you out when it comes down to translating.\n\n\nSentences used in translations are dynamically constructed using parameters,\nthe plural-function and the gender-function.\n\n\n\n\nParameters will be filled in as given and formatted when in the correct format (integer and float as number,\ntime and date and datetime as time. string will remain untouched.).\n\n\nThe plural-function lets you print plurals which is different depending on\nthe locale (see babel.messages.plurals).\n\n\nThe gender-function helps you print out possessive pronouns, or gender-bound\nwords or verbs depending on the context.\n\n\n\n\nConfiguration\n\n\nfrom edmunds.localization.translations.drivers.configtranslator import ConfigTranslator\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'translations': {\n            'enabled': True,\n            'instances': [\n                   {\n                    'name': 'configtranslator',\n                    'driver': ConfigTranslator,\n                },\n            ],\n\n            # The ConfigTranslator uses configuration to fetch the translations.\n            #   To keep the config clean, try splitting the translations up in\n            #   different config files.\n            #   More on how to format these sentences below.\n            'strings': {\n                'en': {\n                    'beautiful': 'This is a beautiful translation in en. Is it not, {name}?',\n                    'smashing': 'A smashing sentence in en!',\n                    'liking': 'I\\'m taking a liking to --gender:{user}__him__her--...',\n                },\n                'en_US': {\n                    'beautiful': 'This is a beautiful translation in en_US. Is it not, {name}?',\n                    'smashing': 'A smashing sentence in en_US!',\n                },\n                'nl': {\n                    'beautiful': 'Dit is een prachtige vertaling in nl. Nietwaar, {name}?',\n                },\n            },\n        },\n    },\n}\n\n\n\n\nThe available drivers are:\n\n\n\n\nConfigTranslator\n: Fetches translations from config\n\n\n\n\nUsage\n\n\nConstructing sentences\n\n\n\n\nParams are defined as follows: \n{paramname}\n.\n\n\nFunctions are defined as follows: \n--functionname:{argname1},{argname2}__option 1__option 2--\n\n\nPlural-function: \n--plural:{count}__{count} apple__{count} apples--\n\n\nGender-function: \n--gender:{user}__his apple__her apple--\n\n\n\n\n\n\nNote: Parameters used as arguments of a function will not be formatted.\n\n\n\n\nExamples:\n\n\n\n\nThis is a beautiful translation in en. Is it not, {name}?\n\n\nA smashing sentence in en!\n\n\nI'm taking a liking to --gender:{user}__him__her--...\n\n\n\n\nUsing translations\n\n\nfrom edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n        # Note: Visitor will use the first location and translation driver!\n\n        sentence = self.visitor.localizator.translate('beautiful', {'name': 'Steve'})\n        # locale 'en':      This is a beautiful translation in en. Is it not, Steve?\n        # locale 'en_US':   This is a beautiful translation in en_US. Is it not, Steve?\n        # locale 'nl':      Dit is een prachtige vertaling in nl. Nietwaar, Steve?\n\n        sentence = self.visitor.localizator.translate('smashing')\n        # locale 'en':      A smashing sentence in en!\n        # locale 'en_US':   A smashing sentence in en_US!\n        # locale 'nl':      A smashing sentence in en!      (using fallback en)\n\n\n        # Usage through the app/manager\n\n        # Localization manager\n        localization_manager = self.app.localization()\n        # Location\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self.request.remote_addr)\n        # Translator\n        translator = localization_manager.translator()\n        # Localizator\n        localizator = localization_manager.localizator(location, translator)\n\n        sentence = localizator.translate('liking', {'user': 'F'})\n        # locale 'en':      I'm taking a liking to her...\n        # locale 'en_US':   I'm taking a liking to her...   (using en without region US)\n        # locale 'nl':      I'm taking a liking to her...   (using fallback en)\n\n        # ...",
            "title": "Translations"
        },
        {
            "location": "/localization/translations/#translations",
            "text": "Translations and user experience go hand in hand like cookies and milk.\nThat's why Edmunds helps you out when it comes down to translating.  Sentences used in translations are dynamically constructed using parameters,\nthe plural-function and the gender-function.   Parameters will be filled in as given and formatted when in the correct format (integer and float as number,\ntime and date and datetime as time. string will remain untouched.).  The plural-function lets you print plurals which is different depending on\nthe locale (see babel.messages.plurals).  The gender-function helps you print out possessive pronouns, or gender-bound\nwords or verbs depending on the context.",
            "title": "Translations"
        },
        {
            "location": "/localization/translations/#configuration",
            "text": "from edmunds.localization.translations.drivers.configtranslator import ConfigTranslator\n\nAPP = {\n    'localization': {\n        'enabled': True,\n\n        'locale': {\n            'fallback': 'en',\n            'supported': ['en', 'en_US', 'nl'],\n        },\n        'time_zone_fallback': 'Europe/Brussels',\n\n        'translations': {\n            'enabled': True,\n            'instances': [\n                   {\n                    'name': 'configtranslator',\n                    'driver': ConfigTranslator,\n                },\n            ],\n\n            # The ConfigTranslator uses configuration to fetch the translations.\n            #   To keep the config clean, try splitting the translations up in\n            #   different config files.\n            #   More on how to format these sentences below.\n            'strings': {\n                'en': {\n                    'beautiful': 'This is a beautiful translation in en. Is it not, {name}?',\n                    'smashing': 'A smashing sentence in en!',\n                    'liking': 'I\\'m taking a liking to --gender:{user}__him__her--...',\n                },\n                'en_US': {\n                    'beautiful': 'This is a beautiful translation in en_US. Is it not, {name}?',\n                    'smashing': 'A smashing sentence in en_US!',\n                },\n                'nl': {\n                    'beautiful': 'Dit is een prachtige vertaling in nl. Nietwaar, {name}?',\n                },\n            },\n        },\n    },\n}  The available drivers are:   ConfigTranslator : Fetches translations from config",
            "title": "Configuration"
        },
        {
            "location": "/localization/translations/#usage",
            "text": "",
            "title": "Usage"
        },
        {
            "location": "/localization/translations/#constructing-sentences",
            "text": "Params are defined as follows:  {paramname} .  Functions are defined as follows:  --functionname:{argname1},{argname2}__option 1__option 2--  Plural-function:  --plural:{count}__{count} apple__{count} apples--  Gender-function:  --gender:{user}__his apple__her apple--    Note: Parameters used as arguments of a function will not be formatted.   Examples:   This is a beautiful translation in en. Is it not, {name}?  A smashing sentence in en!  I'm taking a liking to --gender:{user}__him__her--...",
            "title": "Constructing sentences"
        },
        {
            "location": "/localization/translations/#using-translations",
            "text": "from edmunds.http.controller import Controller\n\nclass MyController(Controller):\n    def login(self):\n\n        # Usage through the visitor object\n        # Note: Visitor will use the first location and translation driver!\n\n        sentence = self.visitor.localizator.translate('beautiful', {'name': 'Steve'})\n        # locale 'en':      This is a beautiful translation in en. Is it not, Steve?\n        # locale 'en_US':   This is a beautiful translation in en_US. Is it not, Steve?\n        # locale 'nl':      Dit is een prachtige vertaling in nl. Nietwaar, Steve?\n\n        sentence = self.visitor.localizator.translate('smashing')\n        # locale 'en':      A smashing sentence in en!\n        # locale 'en_US':   A smashing sentence in en_US!\n        # locale 'nl':      A smashing sentence in en!      (using fallback en)\n\n\n        # Usage through the app/manager\n\n        # Localization manager\n        localization_manager = self.app.localization()\n        # Location\n        location_driver = localization_manager.location()\n        location = location_driver.insights(self.request.remote_addr)\n        # Translator\n        translator = localization_manager.translator()\n        # Localizator\n        localizator = localization_manager.localizator(location, translator)\n\n        sentence = localizator.translate('liking', {'user': 'F'})\n        # locale 'en':      I'm taking a liking to her...\n        # locale 'en_US':   I'm taking a liking to her...   (using en without region US)\n        # locale 'nl':      I'm taking a liking to her...   (using fallback en)\n\n        # ...",
            "title": "Using translations"
        },
        {
            "location": "/auth/introduction/",
            "text": "Authentication\n\n\nAuthentication is managed using \nFlask-Security\n.\n\n\nEdmunds already implements some of the features of\nFlask-Security to get you started.\n\n\nSettings\n\n\nYou can set your authentication preferences in the settings:\n\n\nfrom flask_security import SQLAlchemyUserDatastore\nfrom app.database.models.user import User\nfrom app.database.models.role import Role\n\nSECURITY_PASSWORD_HASH = 'sha512_crypt'\nSECURITY_TRACKABLE = True\nAPP = {\n    'auth':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'authsqlalchemy',\n                'driver': SQLAlchemyUserDatastore,\n                'models': {\n                    'user': User,\n                    'role': Role,\n                },\n            },\n        ],\n    },\n}\n\n\n\n\nYou can have multiple user datastores by defining them\nas instances. Each instance will have their own models.\n\n\nThe available drivers are:\n\n\n\n\nSQLAlchemyUserDatastore\n: User management using SQLAlchemy\n\n\n\n\nUser- and Role-Model\n\n\nBoth the user- and role-model can use the predefined\nmixins of Edmunds. The mixins already define the default\ncolumns for your database-structure.\n\n\n# app/database/role.py\n\nfrom edmunds.auth.models.rolemixin import RoleMixin\nfrom edmunds.database.db import db\n\nclass Role(db.Model, RoleMixin):\n    # __tablename__ = 'role'\n    # __bind_key__ = 'users'\n    pass\n\n# app/database/user.py\n\nfrom edmunds.database.db import relationship, backref\nfrom edmunds.auth.models.usermixin import UserMixin\nfrom app.database.models.role import Role\nfrom app.database.models.userroles import UserRolesTable\nfrom edmunds.database.db import db\n\nclass User(db.Model, UserMixin):\n    # __tablename__ = 'user'\n    # __bind_key__ = 'users_database'\n    roles = relationship(Role, backref=backref('users', lazy='dynamic'), secondary=UserRolesTable)\n\n\n\n\nUsage\n\n\nFetch the \nflask_security.Security\n instance for your config-defined instance: \n\n\nsecurity_instance = app.auth_security()\nsecurity_instance = app.auth_security(name='authsqlalchemy')\n\n\n\n\nFetch the \nflask_security.datastore.UserDatastore\n instance for your\nconfig-defined instance: \n\n\nuserdatastore_instance = app.auth_userdatastore()\nuserdatastore_instance = app.auth_userdatastore(name='authsqlalchemy')\n\nuserdatastore_instance = app.auth_security(name='authsqlalchemy').datastore",
            "title": "Introduction"
        },
        {
            "location": "/auth/introduction/#authentication",
            "text": "Authentication is managed using  Flask-Security .  Edmunds already implements some of the features of\nFlask-Security to get you started.",
            "title": "Authentication"
        },
        {
            "location": "/auth/introduction/#settings",
            "text": "You can set your authentication preferences in the settings:  from flask_security import SQLAlchemyUserDatastore\nfrom app.database.models.user import User\nfrom app.database.models.role import Role\n\nSECURITY_PASSWORD_HASH = 'sha512_crypt'\nSECURITY_TRACKABLE = True\nAPP = {\n    'auth':\n    {\n        'enabled': True,\n        'instances':\n        [\n            {\n                'name': 'authsqlalchemy',\n                'driver': SQLAlchemyUserDatastore,\n                'models': {\n                    'user': User,\n                    'role': Role,\n                },\n            },\n        ],\n    },\n}  You can have multiple user datastores by defining them\nas instances. Each instance will have their own models.  The available drivers are:   SQLAlchemyUserDatastore : User management using SQLAlchemy",
            "title": "Settings"
        },
        {
            "location": "/auth/introduction/#user-and-role-model",
            "text": "Both the user- and role-model can use the predefined\nmixins of Edmunds. The mixins already define the default\ncolumns for your database-structure.  # app/database/role.py\n\nfrom edmunds.auth.models.rolemixin import RoleMixin\nfrom edmunds.database.db import db\n\nclass Role(db.Model, RoleMixin):\n    # __tablename__ = 'role'\n    # __bind_key__ = 'users'\n    pass\n\n# app/database/user.py\n\nfrom edmunds.database.db import relationship, backref\nfrom edmunds.auth.models.usermixin import UserMixin\nfrom app.database.models.role import Role\nfrom app.database.models.userroles import UserRolesTable\nfrom edmunds.database.db import db\n\nclass User(db.Model, UserMixin):\n    # __tablename__ = 'user'\n    # __bind_key__ = 'users_database'\n    roles = relationship(Role, backref=backref('users', lazy='dynamic'), secondary=UserRolesTable)",
            "title": "User- and Role-Model"
        },
        {
            "location": "/auth/introduction/#usage",
            "text": "Fetch the  flask_security.Security  instance for your config-defined instance:   security_instance = app.auth_security()\nsecurity_instance = app.auth_security(name='authsqlalchemy')  Fetch the  flask_security.datastore.UserDatastore  instance for your\nconfig-defined instance:   userdatastore_instance = app.auth_userdatastore()\nuserdatastore_instance = app.auth_userdatastore(name='authsqlalchemy')\n\nuserdatastore_instance = app.auth_security(name='authsqlalchemy').datastore",
            "title": "Usage"
        },
        {
            "location": "/auth/token/",
            "text": "Token Authentication\n\n\nToken authentication can be set up using the \nintroduction\n and\nsome help from \nthis post\n.\n\n\nAdd the \nTokenAuthMiddleware\n-middleware to your routes to protect them. This middleware\nis a wrapper for the\n\nauth_token_required\n-decorator\n:\n\n\nfrom edmunds.auth.middleware.tokenauthmiddleware import TokenAuthMiddleware\nfrom app.http.controllers.mycontroller import MyController\n\napp.route('/loggedin', uses=(MyController, 'get_logged_in')) \\\n    .middleware(TokenAuthMiddleware)\n\n\n\n\nTL;DR\n\n\nThe following request will give you an authentication token:\n\n\n\n\nPost-request to \n/login\n\n\nData:\n\n\nemail\n\n\npassword\n\n\n\n\n\n\nHeaders:\n\n\ncontent-type\n: \napplication/json\n\n\n\n\n\n\n\n\nAdd the token to future requests using either:\n\n\n\n\nRequest-data: \nauth_token\n\n\nHeader: \nAuthentication-Token",
            "title": "Token Authentication"
        },
        {
            "location": "/auth/token/#token-authentication",
            "text": "Token authentication can be set up using the  introduction  and\nsome help from  this post .  Add the  TokenAuthMiddleware -middleware to your routes to protect them. This middleware\nis a wrapper for the auth_token_required -decorator :  from edmunds.auth.middleware.tokenauthmiddleware import TokenAuthMiddleware\nfrom app.http.controllers.mycontroller import MyController\n\napp.route('/loggedin', uses=(MyController, 'get_logged_in')) \\\n    .middleware(TokenAuthMiddleware)",
            "title": "Token Authentication"
        },
        {
            "location": "/auth/token/#tldr",
            "text": "The following request will give you an authentication token:   Post-request to  /login  Data:  email  password    Headers:  content-type :  application/json     Add the token to future requests using either:   Request-data:  auth_token  Header:  Authentication-Token",
            "title": "TL;DR"
        },
        {
            "location": "/auth/session/",
            "text": "Session Authentication\n\n\nSession authentication can be set up using the \nintroduction\n.\n\n\nAdd the \nSessionAuthMiddleware\n-middleware to your routes to protect them. This middleware\nis a wrapper for the\n\nlogin_required\n-decorator\n:\n\n\nfrom edmunds.auth.middleware.sessionauthmiddleware import SessionAuthMiddleware\nfrom app.http.controllers.mycontroller import MyController\n\napp.route('/loggedin', uses=(MyController, 'get_logged_in')) \\\n    .middleware(SessionAuthMiddleware)",
            "title": "Session Authentication"
        },
        {
            "location": "/auth/session/#session-authentication",
            "text": "Session authentication can be set up using the  introduction .  Add the  SessionAuthMiddleware -middleware to your routes to protect them. This middleware\nis a wrapper for the login_required -decorator :  from edmunds.auth.middleware.sessionauthmiddleware import SessionAuthMiddleware\nfrom app.http.controllers.mycontroller import MyController\n\napp.route('/loggedin', uses=(MyController, 'get_logged_in')) \\\n    .middleware(SessionAuthMiddleware)",
            "title": "Session Authentication"
        },
        {
            "location": "/auth/basic/",
            "text": "Basic HTTP Authentication\n\n\nBasic HTTP authentication can be set up using the \nintroduction\n.\n\n\nAdd the \nBasicAuthMiddleware\n-middleware to your routes to protect them. This middleware\nis a wrapper for the\n\nhttp_auth_required\n-decorator\n:\n\n\nfrom edmunds.auth.middleware.basicauthmiddleware import BasicAuthMiddleware\nfrom app.http.controllers.mycontroller import MyController\n\napp.route('/loggedin', uses=(MyController, 'get_logged_in')) \\\n    .middleware(BasicAuthMiddleware)\napp.route('/loggedin', uses=(MyController, 'get_logged_in')) \\\n    .middleware(BasicAuthMiddleware, 'myrealm')",
            "title": "Basic HTTP Authentication"
        },
        {
            "location": "/auth/basic/#basic-http-authentication",
            "text": "Basic HTTP authentication can be set up using the  introduction .  Add the  BasicAuthMiddleware -middleware to your routes to protect them. This middleware\nis a wrapper for the http_auth_required -decorator :  from edmunds.auth.middleware.basicauthmiddleware import BasicAuthMiddleware\nfrom app.http.controllers.mycontroller import MyController\n\napp.route('/loggedin', uses=(MyController, 'get_logged_in')) \\\n    .middleware(BasicAuthMiddleware)\napp.route('/loggedin', uses=(MyController, 'get_logged_in')) \\\n    .middleware(BasicAuthMiddleware, 'myrealm')",
            "title": "Basic HTTP Authentication"
        },
        {
            "location": "/auth/roles/",
            "text": "Roles\n\n\nThe \nRolesAcceptedMiddleware\n-middleware and the \nRolesRequiredMiddleware\n-middleware\nare two wrapper for respectively the\n\nroles_accepted\n-decorator\n\nand the\n\nroles_required\n-decorator\n.\n\n\nThey are slightly modified so they don't redirect when the requirements are not met.\nThey will just abort with the Forbidden-statuscode (403).\n\n\nAdd them to your routes to protect them:\n\n\nfrom edmunds.auth.middleware.rolesacceptedmiddleware import RolesAcceptedMiddleware\nfrom edmunds.auth.middleware.rolesrequiredmiddleware import RolesRequiredMiddleware\nfrom app.http.controllers.mycontroller import MyController\n\napp.route('/acceptsroles', uses=(MyController, 'acceptsroles')) \\\n    .middleware(RolesAcceptedMiddleware, 'role1', 'role2')\napp.route('/requiresroles', uses=(MyController, 'requiresroles')) \\\n    .middleware(RolesRequiredMiddleware, 'role2', 'role3')\n\n\n\n\nMethods\n\n\nRead the \nUserDataStore\n-documentation\nto see how roles are added and assigned to users.",
            "title": "Roles"
        },
        {
            "location": "/auth/roles/#roles",
            "text": "The  RolesAcceptedMiddleware -middleware and the  RolesRequiredMiddleware -middleware\nare two wrapper for respectively the roles_accepted -decorator \nand the roles_required -decorator .  They are slightly modified so they don't redirect when the requirements are not met.\nThey will just abort with the Forbidden-statuscode (403).  Add them to your routes to protect them:  from edmunds.auth.middleware.rolesacceptedmiddleware import RolesAcceptedMiddleware\nfrom edmunds.auth.middleware.rolesrequiredmiddleware import RolesRequiredMiddleware\nfrom app.http.controllers.mycontroller import MyController\n\napp.route('/acceptsroles', uses=(MyController, 'acceptsroles')) \\\n    .middleware(RolesAcceptedMiddleware, 'role1', 'role2')\napp.route('/requiresroles', uses=(MyController, 'requiresroles')) \\\n    .middleware(RolesRequiredMiddleware, 'role2', 'role3')",
            "title": "Roles"
        },
        {
            "location": "/auth/roles/#methods",
            "text": "Read the  UserDataStore -documentation\nto see how roles are added and assigned to users.",
            "title": "Methods"
        }
    ]
}